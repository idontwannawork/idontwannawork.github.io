<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Come as you are</title>
		<link>https://idontwannawork.github.io/posts/</link>
		<description>Recent content in Posts on Come as you are</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>ja</language>
		<lastBuildDate>Tue, 04 Jun 2019 17:11:23 +0900</lastBuildDate>
		<atom:link href="https://idontwannawork.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>TASCAMのiXZを使ってiPhoneでレコーディングする</title>
			<link>https://idontwannawork.github.io/posts/recocrd-with-tascam-ixz/</link>
			<pubDate>Tue, 04 Jun 2019 17:11:23 +0900</pubDate>
			
			<guid>https://idontwannawork.github.io/posts/recocrd-with-tascam-ixz/</guid>
			<description>そもそもiXZって何ぞや TASCAMが販売しているスマートフォン・タブレット端末用オーディオインターフェイスです。発売は2011年とめちゃく</description>
			<content type="html"><![CDATA[

<h2 id="そもそもixzって何ぞや">そもそもiXZって何ぞや</h2>

<p><img src="IMG_0671.png" alt="pic" /></p>

<p><a href="https://tascam.jp/jp/product/ixz/top">TASCAMが販売している</a>スマートフォン・タブレット端末用オーディオインターフェイスです。発売は2011年とめちゃくちゃ昔なのですが現役で販売されていることからもわかる通り、スマートフォン・タブレット端末で利用できる手軽なインターフェイスの王道です。</p>

<p>特徴としては、スマートフォンなどに「アナログで接続する」という点。そして、ギター専用の<a href="https://www.ikmultimedia.com/products/irig2/?L=JP">iRig</a>のような「スマートフォンに直接接続する」仕様であるにもかかわらず、ギターだけじゃなくコンデンサーマイクの利用も可能な点でしょうか。</p>

<h2 id="仕様">仕様</h2>

<p><img src="IMG_0679.png" alt="pic" /></p>

<p>サイズは<code>106（W）× 40（H）× 45（D）mm</code>と、最近大型化しているスマートフォンと比べると厚さ以外は割とコンパクト。単3電池2本がセット可能ですが、電池を含めないと100gを切るくらいの軽量さ。</p>

<p>入力端子はハイインピーダンス入力に対応していて、ギターなどを直接接続できます。また、端子がXLR/TSコンボジャック仕様で、ギター・ベースやシンセサイザーなどの標準プラグだけでなく、XLR端子をもつマイクも接続可能です。さらに、単3電池2本によるファントム電源の供給が可能で、コンデンサーマイクの接続もできるとあって、実売価格が4000円前後の商品としては割と充実した装備です。</p>

<p>スマートフォンやタブレットへの接続には、本体から「ニョキッ」と生えている4極端子を用います。デバイスのヘッドホン端子に接続することで、アナログでのレコーディングができるようになるわけです。最近だとLightning端子などに接続してデジタルでレコーディングする機種もありますが、ヘッドホン端子でのアナログ接続ならAndroidとiOSの双方で利用できるので、ありがたいです。まぁ、最近はそもそも<a href="https://www.apple.com/jp/iphone-xs/">ヘッドホン端子</a>が<a href="https://www.apple.com/jp/iphone-xr/">存在しないスマホ</a>も<a href="https://www.nttdocomo.co.jp/product/smart_phone/so01l/">ゴロゴロ</a>ありますけどね・・・。</p>

<p>ちなみに、説明書などにはこの機種が利用できるデバイスを「4極端子（CTIA規格）を搭載した端末に限ります」としているのですが、4極端子を装備していないデバイスって最近あるんですかね？</p>

<p>また、本体背面の3.5mmステレオミニジャックにイヤホンやヘッドホンを接続することで、音声出力をモニターしながらレコーディングできます。まぁ、この「モニターしながらレコーディングできる」って言うのが、<strong>ちょっとした罠</strong> になっているんですけどね・・・_(┐「ε:)_（後述）</p>

<p>なお、当機種はiOSにおける動作検証の対象機材となっており<a href="https://tascam.com/jp/support/news/5751">サポートページ</a>でiOS12における動作が確認されていることから、今後もしばらくは安心して使用できます。ただ、Lightning端子に接続するようなデジタル仕様じゃないので、OSの変更で影響が出てくるのか？と問われると、「ぶっちゃけ関係ないんじゃないの？」と首をかしげるところではありますが。</p>

<p>ちなみに、細かいところにツッコミを入れるなら、多分USBオーディオインターフェイスじゃないと思うんですけど（名推理）</p>

<p><img src="2019-06-04-17-36-25.png" alt="pic" /></p>

<h2 id="使い方">使い方</h2>

<h3 id="接続">接続</h3>

<p>使い方は、正面の入力端子にギターやシンセを接続し、背面の4極ミニプラグケーブルをスマートフォンやタブレットのヘッドホンを接続します。また、本体の背面にあるヘッドホン端子へ対しヘッドホンなどを接続して音声出力をモニターします。</p>

<p><img src="2019-06-04-18-09-02.png" alt="pic" /></p>

<p>このとき、標準ジャックを利用するのであれば電池は不要です。電池は、コンデンサーマイクを接続する際のファントム電源の供給にのみ利用するからです。</p>

<h3 id="音量調整">音量調整</h3>

<p>音量はデバイスのボリュームを調整することで操作します。</p>

<h3 id="さあレコーディング-あれ">さあレコーディング！・・・あれ？</h3>

<p>接続はこれで終わりです。ただこれだけではレコーディングできません。そう、<strong>アプリ</strong>が必要なのですよ・・・！</p>

<h3 id="アプリは">アプリは？</h3>

<p>iXZ用のアプリというものはリリースされていません。じゃあどうするか？</p>

<p><strong>好きなアプリを使えばいいんじゃね？</strong>、です。</p>

<p>そう言ってしまうと冗談に聞こえますが割とマジです。何せアナログの入力なので、プロテクトも何もないわけですから、極端なことを言えばスマホに標準搭載されているカメラアプリを使って録画してもいいわけです。あるいは、iOSであれば<a href="https://www.apple.com/jp/ios/garageband/">GarageBand</a>がパッと思い浮かぶところでしょうか。</p>

<p><strong>慣れ親しんだアプリを使ってね</strong>という、TASCAMの思いやりなのかもしれないデスネ（ぐるぐる目）</p>

<h2 id="つまづいたところ">つまづいたところ</h2>

<p>単純明快なアナログ接続のiXZですが、スムーズに万事うまく行ったわけではありませんでした。というのが、<strong>音声入力のモニターができるか否かはアプリに依存</strong>する点です。</p>

<p>当初、この機種の動作確認を行うのに、iPhoneのカメラアプリを利用しました。ところが、接続したイヤホンから音声のモニターができないのです。かすかな「サー」というホワイトノイズが彼方に聞こえるのみで、INPUTのダイヤルをひねろうとiPhoneの音量を調整しようと一向に音声をモニターできません。</p>

<p>「あちゃー、初期不良かなー」と思いましたが、録画した動画を再生してみるとしっかりと入力した音声が録画されていました。<strong>つまり、音声入力は取得できているけど、それをモニターできない</strong>わけでした。</p>

<p>少し調べてみたところ「モニターの可否は、レコーディングに利用するアプリが<strong>入力された音声を出力へ返してくれるかどうか</strong>に依存している」ということがわかりました。</p>

<p>つまり、iXZは録音するデバイス（この場合iPhone）からの音声出力を単純にイヤホンに出力しているだけで、iXZ本体でイヤホンジャックに向けて配線しているわけではない、ということです。なので、モニタリングできるよう入力された音声を出力できるようなアプリを利用すればよい、ということになります。</p>

<p>ただし、GarageBandのようなアプリは動画ではなく音声のみを録音するので、「動画を取りつつ音声をモニターしたい」というニーズには残念ながら大抵のアプリが非対応、ということになります。</p>

<p>この場合、根本的な解決策はモニターできる録画アプリを探すことになります。が、今回は録画したかったものがKORGのvolcaをいじる場面だったので、ステレオミニプラグを分岐させるアダプターを利用しました。volcaのアウトプットに分岐アダプターを接続し、一方はiXZに接続しつつもう一方をイヤホンやスピーカーに接続することで、モニターしながら録画できる環境にしました。</p>

<h2 id="使った感じはどうなのよ">使った感じはどうなのよ？</h2>

<p><strong>スゲーお手軽・・・！！</strong> _(┐「ε:)_</p>

<p>これなんですよねぇ。レコーディングしたい機材をパパッと接続して、アプリを起動して録音するだけ。それ以上の操作は必要ないうえ、どこへでも持って行けるサイズ。ギターなどを接続するなら電池も不要で、とにかく身軽かつ気軽。</p>

<p>アナログ特有のノイズはどうしてもありますが、言うほど気にはなりません。これ以上を望むならもう少し出費してデジタルのオーディオインターフェイスを準備するほうが、精神衛生上よろしいかと思います。</p>

<p>というか、この手のインターフェイスでギターとマイクが接続できるものはiXZが今の所最安値です。より良い環境を求めるなら自動的に出費する以外にはありません。強いて言えばiRigですけど、あれはギターとかの標準プラグのみ対応してる機種ですしね。</p>

<p>気になったと言えば、iXZ本体にイヤホンを接続してモニターする場合、原音と比べて若干音がマイルドになるというか、少しハリがなくなるというか、そんな気がします。良く言えば「角が取れて落ち着く」、悪く言えば「ヌケが悪くなってダルい」。ただし、イヤホンはあくまでもモニター用ですしiPhone本体にはそこそこのヌケで録音されているので問題ないでしょう。</p>

<p>そして何よりこの値段設定が素晴らしい。コストパフォーマンスとしては、100点満点じゃないでしょうか。</p>

<h2 id="まとめ">まとめ</h2>

<p><strong>身軽でお手軽な上、コスパまで備えた働き者</strong>です。</p>

<p>スマートフォンやタブレットを利用してレコーディングしたい、ギターだけじゃなくてマイクも使いたい、小難しいのはいいからとにかく気軽にやりたい。</p>

<p>そんな人にぜひオススメしたい、良質なインターフェイスです。</p>
]]></content>
		</item>
		
		<item>
			<title>PythonでMarkdownファイルをHTMLへ変換する</title>
			<link>https://idontwannawork.github.io/posts/convert-markdown-to-html-with-python/</link>
			<pubDate>Fri, 24 May 2019 14:50:30 +0900</pubDate>
			
			<guid>https://idontwannawork.github.io/posts/convert-markdown-to-html-with-python/</guid>
			<description>はじめに 以前、VS CodeでMarkdownをPDFに自動で変換する方法を書いたのだけど、今度はHTMLファイルに変換する必要が出てきたので</description>
			<content type="html"><![CDATA[

<h2 id="はじめに">はじめに</h2>

<p>以前、<a href="/posts/convert-markdown-to-pdf-with-vscode/">VS CodeでMarkdownをPDFに自動で変換する</a>方法を書いたのだけど、今度はHTMLファイルに変換する必要が出てきたので勉強がてら、Pythonで書くことにしました。と言っても難しい処理では全然ないんだけど・・・_(┐「ε:)_</p>

<p>ちなみに、<a href="/posts/convert-markdown-to-pdf-with-vscode/">前の記事</a>で紹介した拡張機能<a href="https://marketplace.visualstudio.com/items?itemName=yzane.markdown-pdf">Markdown PDF</a>を使えばHTMLにも変換できます。ただ、今回はVS Codeがないというシチュエーションでファイル変換したいのと、自分が作成したスタイルシートでHTMLファイルを生成したかったため、VS Codeの拡張機能を頼らない方法を取りました。</p>

<p>というわけで、Pythonを使ったMarkdownファイルをHTMLへ変換する手順について書きます。</p>

<h2 id="リポジトリ">リポジトリ</h2>

<p><a href="https://github.com/idontwannawork/markdowntohtml">こちら</a>にソースコード一式を置いてあります。</p>

<h2 id="環境">環境</h2>

<ul>
<li>Python ※3.x系</li>
<li>Markdown</li>
</ul>

<p><a href="https://python-markdown.github.io/">Markdown</a>は事前に<code>pip</code>しておく。</p>
<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">pip install Markdown</code></pre></div>
<p>一応プラットフォームに関しては、MacやWindowsに限らず動作する・・・はず_(┐「ε:)_</p>

<h2 id="概要">概要</h2>

<p>フォルダ中に存在するmdファイルを取得して、HTMLファイルに変換します。</p>

<h2 id="詳細">詳細</h2>

<h3 id="ファイル">ファイル</h3>

<ul>
<li><p>mdtohtml.py</p>

<p>Pythonで記述された本体。実行の際は当ファイルを指定します。</p></li>

<li><p>style.css</p>

<p>CSSが書かれたファイル。生成されたHTMLファイルに<code>&lt;style&gt;</code>タグで記述されます。スタイルの変更を行いたい場合、当ファイルを書き換えてHTMLを生成してください。</p></li>
</ul>

<h3 id="使い方">使い方</h3>

<ol>
<li><p>変換したいmdファイルがあるフォルダに上記の2ファイルを配置します。</p>
<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">$ ls
README.md    iamacat.md   main.css     mdtohtml.py</code></pre></div></li>

<li><p>配置したら、そのフォルダにて下記のコマンドを実行します。</p>
<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">$ python mdtohtml.py
iamacat.md の変換を開始します
-----------------------------------
iamacat.md を iamacat.html へ変換しました
README.md の変換を開始します
-----------------------------------
README.md を README.html へ変換しました
$ ls
README.html   README.md     iamacat.html  iamacat.md    main.css      mdtohtml.py</code></pre></div></li>
</ol>

<h3 id="処理内容">処理内容</h3>

<p>実行されたフォルダ中に存在するmdファイルを取得して、HTMLファイルに変換して同じフォルダーに出力します。mdファイルが複数ある場合は、すべてHTML化します。</p>

<h2 id="コード">コード</h2>

<p>基本的には、HTML化はMarkdownに丸投げしています。丸投げした後、必要な<code>&lt;html&gt;</code>タグなどを付与しているだけです。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">markdown</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">glob</span>

<span class="c1"># Markdown拡張</span>
<span class="n">mdextensions</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;tables&#34;</span><span class="p">]</span>


<span class="c1"># mdファイルの変換</span>
<span class="k">def</span> <span class="nf">convertHtml</span><span class="p">(</span><span class="n">mdpath</span><span class="p">,</span> <span class="n">htmlpath</span><span class="p">,</span> <span class="n">style</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">mdpath</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&#34;utf-8&#34;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="c1"># Markdown の import 文を除去</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;@import &#34;.+&#34;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="c1"># HTMLに変換</span>
        <span class="n">body</span> <span class="o">=</span> <span class="n">markdown</span><span class="o">.</span><span class="n">Markdown</span><span class="p">(</span><span class="n">extensions</span><span class="o">=</span><span class="n">mdextensions</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

        <span class="n">html</span> <span class="o">=</span> <span class="s1">&#39;&lt;html lang=&#34;ja&#34;&gt;&lt;meta charset=&#34;utf-8&#34;&gt;&#39;</span>
        <span class="n">html</span> <span class="o">+=</span> <span class="s1">&#39;&lt;style&gt;&#39;</span> <span class="o">+</span> <span class="n">style</span> <span class="o">+</span> <span class="s1">&#39;&lt;/style&gt;&#39;</span>
        <span class="n">html</span> <span class="o">+=</span> <span class="s1">&#39;&lt;body&gt;&#39;</span> <span class="o">+</span> <span class="n">body</span> <span class="o">+</span> <span class="s1">&#39;&lt;/body&gt;&lt;/html&gt;&#39;</span>

        <span class="c1"># HTMLで出力</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">((</span><span class="n">htmlpath</span><span class="p">),</span> <span class="s2">&#34;w&#34;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&#34;utf-8&#34;</span><span class="p">)</span> <span class="k">as</span> <span class="n">g</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="c1"># スタイルは、style.cssを参照する</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;./style.css&#39;</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&#34;utf-8&#34;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">style</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">mdfile</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&#34;*.md&#34;</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&#34;</span><span class="si">%s</span><span class="s2"> の変換を開始します&#34;</span> <span class="o">%</span> <span class="n">mdfile</span><span class="p">)</span>
            <span class="n">htmlname</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.md$&#39;</span><span class="p">,</span> <span class="s1">&#39;.html&#39;</span><span class="p">,</span> <span class="n">mdfile</span><span class="p">)</span>
            <span class="n">convertHtml</span><span class="p">(</span><span class="n">mdfile</span><span class="p">,</span> <span class="n">htmlname</span><span class="p">,</span> <span class="n">style</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&#34;-----------------------------------&#34;</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&#34;</span><span class="si">%s</span><span class="s2"> を </span><span class="si">%s</span><span class="s2"> へ変換しました&#34;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mdfile</span><span class="p">,</span> <span class="n">htmlname</span><span class="p">))</span></code></pre></div>
<p>途中の<code>style.css</code>は任意のスタイルを記述したファイルを、pyファイルと同じフォルダに格納しておきます。</p>

<p>なお、style.cssの内容はとりあえず下記の内容を記述しています。用途に応じて、追記したり別のcssファイルに置き換えてもらえればいいかと思います。</p>
<div class="highlight"><pre class="chroma"><code class="language-css" data-lang="css"><span class="nt">body</span> <span class="p">{</span>

  <span class="k">font-family</span><span class="p">:</span> <span class="s2">&#34;Hiragino Kaku Gothic Pro&#34;</span><span class="p">,</span><span class="kc">sans-serif</span><span class="p">;</span>
  <span class="k">font-size</span><span class="p">:</span> <span class="mi">14</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">padding</span><span class="p">:</span> <span class="mi">0</span> <span class="mi">12</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">line-height</span><span class="p">:</span> <span class="mi">23</span><span class="kt">px</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">img</span> <span class="p">{</span>
  <span class="k">max-width</span><span class="p">:</span> <span class="mi">100</span><span class="kt">%</span><span class="p">;</span>
  <span class="k">max-height</span><span class="p">:</span> <span class="mi">100</span><span class="kt">%</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">hr</span> <span class="p">{</span>
  <span class="k">border</span><span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">height</span><span class="p">:</span> <span class="mi">2</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">border-bottom-width</span><span class="p">:</span> <span class="mi">2</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">border-bottom-style</span><span class="p">:</span> <span class="kc">dotted</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">h1</span> <span class="p">{</span>
  <span class="k">padding-bottom</span><span class="p">:</span> <span class="mf">0.4</span><span class="kt">em</span><span class="p">;</span>
  <span class="k">line-height</span><span class="p">:</span> <span class="mf">1.2</span><span class="p">;</span>
  <span class="k">border-bottom-width</span><span class="p">:</span> <span class="mi">1</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">border-bottom-style</span><span class="p">:</span> <span class="kc">solid</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">h1</span><span class="o">,</span> <span class="nt">h2</span><span class="o">,</span> <span class="nt">h3</span><span class="o">,</span> <span class="nt">h4</span><span class="o">,</span> <span class="nt">h5</span><span class="o">,</span> <span class="nt">h6</span> <span class="p">{</span>
  <span class="k">font-weight</span><span class="p">:</span> <span class="kc">normal</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>
<h2 id="参考文献">参考文献</h2>

<p><a href="https://python-markdown.github.io/">Python-Markdown</a></p>

<p><a href="http://oboe2uran.hatenablog.com/entry/2019/01/25/150934">Markdownファイルを Python で PDF にする</a></p>
]]></content>
		</item>
		
		<item>
			<title>VS CodeでMarkdownをPDFに自動で変換する</title>
			<link>https://idontwannawork.github.io/posts/convert-markdown-to-pdf-with-vscode/</link>
			<pubDate>Wed, 15 May 2019 13:44:12 +0900</pubDate>
			
			<guid>https://idontwannawork.github.io/posts/convert-markdown-to-pdf-with-vscode/</guid>
			<description>はじめに Markdownで記述したmdファイルは、エンジニア間ではそのまま利用することが多いように思います（GitHubなどにREADME.</description>
			<content type="html"><![CDATA[

<h2 id="はじめに">はじめに</h2>

<p>Markdownで記述したmdファイルは、エンジニア間ではそのまま利用することが多いように思います（GitHubなどにREADME.mdとしてアップするとか）。ところが、メールに添付したり印刷する等、外部へ持ち出す際はPDFに変換しておいた方がいろいろ安心。とくに「mdファイルって何？」みたいなお客さんにドキュメントを渡さないといけない場合とか・・・。</p>

<p>MarkdownをPDF化するのは、Pandocを利用する方法もあるのですが、ここではVisual Studio Code（以下、VS Code）の拡張機能である「<a href="https://marketplace.visualstudio.com/items?itemName=yzane.markdown-pdf">Markdown PDF</a>」を利用します。</p>

<h2 id="環境">環境</h2>

<ul>
<li>Windows 10</li>
<li>VS Code</li>
</ul>

<h2 id="インストール">インストール</h2>

<p>VS Codeにて、Ctrl＋Shift＋Xで拡張機能の検索窓に「Markdown PDF」と入力するか、上記のリンクをクリックします。検索結果から「Markdown PDF」を選択し、インストールします。Markdown PDFをインストールしてから、VS Codeで適当なMarkdownファイルを最初に開いた際、Chromiumのダウンロードが自動で始まります。ちなみに、なんでChromiumが必要かというと、Markdown PDFがPDF変換するのに利用しているから。</p>

<h2 id="使い方">使い方</h2>

<ol>
<li>PDF化したいMarkdownファイルを開く。</li>
<li>F1キーを押すか、Ctrl+Shift+Pキーを押しコマンドパレットを表示させる。</li>

<li><p>exportと入力すると下記のメニューが表示される。</p>

<ul>
<li>markdown-pdf: Export (settings.json)</li>
<li>markdown-pdf: Export (pdf)</li>
<li>markdown-pdf: Export (html)</li>
<li>markdown-pdf: Export (png)</li>
<li>markdown-pdf: Export (jpeg)</li>
<li>markdown-pdf: Export (all: pdf, html, png, jpeg)</li>
</ul>

<p>この中からExport (pdf)を選択する。</p></li>

<li><p>少し待つと、Markdownと同一のフォルダーにPDFが生成される。</p></li>
</ol>

<h2 id="自動化">自動化</h2>

<p>上記の使い方ではPDFへ変換するのに、毎回コマンドパレットを表示してコマンドを入力し、どのファイル形式でエクスポートするかを選択する必要があります。これを特定の変換先（今回はPDF）に限定して自動変換するよう設定します。</p>

<ol>
<li><p>「ファイル」メニュー＞「基本設定」＞「設定」を選択するか、<code>Ctrl＋,</code>で直接画面を開く。</p></li>

<li><p>setting.jsonファイルを開いて下記のように設定する。</p>

<pre><code>&quot;markdown-pdf.convertOnSave&quot;: true,
&quot;markdown-pdf.type&quot;: [
    &quot;pdf&quot;
],
</code></pre></li>

<li><p>設定内容を書き込んだらVS Codeを1度再起動する。</p></li>
</ol>

<p>これで、Markdownファイルを編集し保存したタイミングで自動的にPDFへ変換するようになります。</p>

<h2 id="注意">注意</h2>

<p>この拡張機能は変換したファイルの出力先を変更できないので、必ずMarkdownファイルが格納されているフォルダーと同じ場所に出力されます。また、出力先ファイル名も指定できないので、同一名のファイルが既存である場合は自動的に上書きします。</p>
]]></content>
		</item>
		
		<item>
			<title>イテレータを複数回ループしたい</title>
			<link>https://idontwannawork.github.io/posts/iterator-will-return-blank-with-loop-twice/</link>
			<pubDate>Wed, 15 May 2019 11:57:24 +0900</pubDate>
			
			<guid>https://idontwannawork.github.io/posts/iterator-will-return-blank-with-loop-twice/</guid>
			<description>なんのこっちゃ？ 実行しようとしていたのはこんなコードでした。 &amp;gt;&amp;gt;&amp;gt; import re &amp;gt;&amp;gt;&amp;gt; s = &amp;quot;hogefugapiyofoobarbaz1234567890abc987efg654hij321&amp;quot; &amp;gt;&amp;gt;&amp;gt; iter = re.finditer(&amp;quot;b..&amp;quot;, s) ← finditer()は結果をイテレータで返す &amp;gt;&amp;gt;&amp;gt; for i in iter:</description>
			<content type="html"><![CDATA[

<h2 id="なんのこっちゃ">なんのこっちゃ？</h2>

<p>実行しようとしていたのはこんなコードでした。</p>

<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; s = &quot;hogefugapiyofoobarbaz1234567890abc987efg654hij321&quot;
&gt;&gt;&gt; iter = re.finditer(&quot;b..&quot;, s)    ← finditer()は結果をイテレータで返す
&gt;&gt;&gt; for i in iter:
...     print(i.start())
...
15
18
32
&gt;&gt;&gt; for i in iter:
...     print(i.start())
...
&gt;&gt;&gt;    ← 同じループを実行しても最初のループと異なり結果が返ってこない
</code></pre>

<p>このように、同一のイテレータに対しループ処理を複数回行うと、2回目以降のループは結果が空になってしまいます。</p>

<p>ちなみにジェネレータでも上記のような複数回のループ処理を行おうとすると、<a href="https://qiita.com/tomotaka_ito/items/15b5999c76001dbc9a58">2回目以降のループで結果が空になる</a>らしいですが、ジェネレータについては別途まとめて記事にしようと思います（まだ勉強中）。</p>

<h2 id="なんでこーなるの">なんでこーなるの？</h2>

<p><a href="https://docs.python.org/ja/3/glossary.html#term-iterator">イテレータ</a>が持つ要素を取得したい場合、__next__() メソッド（または組み込み関数の<code>next()</code>）を繰り返し呼び出すと、イテレータ中の要素を1つずつ返します。このメソッドは集合から1つずつ要素を<strong>取り出して</strong>います。取り出しているので、すべて取り出し終わったら元の集合には要素が存在しません。よって2回目以降のループは空っぽになります（要素がない場合は、StopIteration例外を返す）。</p>

<p>※「取り出す」という表現が正確かどうかはちょっと自信がありません。メソッドや関数の「next」という名前の通り「次の要素へ」という挙動と、同じ要素を複数回取得できないことから「取り出す」という表現を使っています。</p>

<p>なお、直接関係はありませんが、<a href="https://docs.python.org/ja/3/library/functions.html#map"><code>map()</code></a>や<a href="https://docs.python.org/ja/3/library/functions.html#filter"><code>filter()</code></a>はイテレータを返す（Python3での話）ので、返されたオブジェクトについて<code>list()</code>などを複数回実行すると、上記のように<a href="https://stackoverflow.com/questions/19759247/listing-a-filter-object-twice-will-return-a-blank-list">2回目以降は空っぽになってしまう</a>ようです。</p>

<pre><code>&gt;&gt;&gt; list = [1, 2, 3]
&gt;&gt;&gt; f = filter(None, list)
&gt;&gt;&gt; list(list)
[1, 2, 3]
&gt;&gt;&gt; list(list)
[1, 2, 3] ← リストlistに複数回listしても結果が返ってくる
&gt;&gt;&gt; list(f)
[1, 2, 3]
&gt;&gt;&gt; list(f)
[] ← イテレータに複数回listすると2回目以降ブランクになる
&gt;&gt;&gt;
</code></pre>

<h2 id="そもそもイテレータって">そもそもイテレータって？</h2>

<p><a href="https://docs.python.org/ja/3/glossary.html#term-iterator">iterator</a>とはオブジェクトの一種で、データの走査方法について表現するものです。なんのこっちゃ、という感じですが「要素を1つずつ繰り返し取得できる構造を持っていて（<code>iterable</code>）、実際に順次取得ができる」オブジェクトっていう感じかと。</p>

<pre><code>&gt;&gt;&gt; list = [1, 2, 3]
&gt;&gt;&gt; i = iter(list)
&gt;&gt;&gt; type(list)
&lt;class 'list'&gt;
&gt;&gt;&gt; type(i)
&lt;class 'list_iterator'&gt;
&gt;&gt;&gt; print(next(i))
1
&gt;&gt;&gt; print(next(i))
2
&gt;&gt;&gt; print(next(i))
3
&gt;&gt;&gt; print(next(i))
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
StopIteration ← 「これ以上next()で取り出せる要素ねぇよ！」と言っている
&gt;&gt;&gt;
</code></pre>

<p>これと似たオブジェクトに<a href="https://docs.python.org/ja/3/glossary.html#term-iterable">itetable</a>（反復可能オブジェクト）があります。こちらはデータの構造そのものについて表現しており、<code>iterator</code>とは別物です。たとえばリストやタプル、辞書などは<code>iterable</code>で、オブジェクトに対しアクセスすることで、要素を1つずつ取得することができる<strong>構造</strong>のことを指しています。つまり、先述の<code>iterator</code>は<code>iterable</code>に含まれるわけです。</p>

<p>ちなみに「iterable」の英単語本来の意味は<a href="https://ejje.weblio.jp/content/iterable">「繰り返し可能な」という形容詞</a>。</p>

<h2 id="どうすれば回避できる">どうすれば回避できる？</h2>

<h3 id="変数に格納する">変数に格納する</h3>

<p>再利用したいなら、単純に変数へ格納しちゃえという方法。</p>

<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; s = &quot;hogefugapiyofoobarbaz1234567890abc987efg654hij321&quot;
&gt;&gt;&gt; iter = re.finditer(&quot;b..&quot;, s)
&gt;&gt;&gt; type(iter)
&lt;class 'callable_iterator'&gt;
&gt;&gt;&gt; lists = list(iter)
&gt;&gt;&gt; type(lists)
&lt;class 'list'&gt;
&gt;&gt;&gt; for i in lists:
...     print(i)
...
&lt;_sre.SRE_Match object; span=(15, 18), match='bar'&gt;
&lt;_sre.SRE_Match object; span=(18, 21), match='baz'&gt;
&lt;_sre.SRE_Match object; span=(32, 35), match='bc9'&gt;
&gt;&gt;&gt; for i in lists:
...     print(i.start())
...
15
18
32
&gt;&gt;&gt; for i in lists:
...     print(i.start())
...
15
18
32    ← 複数回ループしても結果が返ってきている
&gt;&gt;&gt;
</code></pre>

<p><code>filter()</code>などのイテレータを返すものも同様。</p>

<pre><code>&gt;&gt;&gt; list = [1, 2, 3]
&gt;&gt;&gt; f = filter(None, list)
&gt;&gt;&gt; type(f)
&lt;class 'filter'&gt;
&gt;&gt;&gt; listed = list(f)
&gt;&gt;&gt; type(listed)
&lt;class 'list'&gt;
&gt;&gt;&gt; list(listed)
[1, 2, 3]
&gt;&gt;&gt; list(listed)
[1, 2, 3]
&gt;&gt;&gt; list(f)
[]
&gt;&gt;&gt;
</code></pre>

<h3 id="リストでループする">リストでループする</h3>

<p>今回の場合で言うと<code>finditer()</code>ではなく<code>findall()</code>を用いて、イテレータでなくリストでループするようにします。</p>

<pre><code>&gt;&gt;&gt; list = re.findall(&quot;b..&quot;, s)
&gt;&gt;&gt; for item in list:
...     print(item)
...
bar
baz
bc9
&gt;&gt;&gt; for item in list:
...     print(item)
...
bar
baz
bc9
</code></pre>

<p><code>findall()</code>はリストを返すメソッド。リスト<code>list</code>に対しては、ループ処理を何回行っても同様な結果が出力されます。これなら上記のような問題は発生しませんが、このあたりは要求される機能と相談する必要があると思います。</p>

<h3 id="itertoolsを用いる">itertoolsを用いる</h3>

<p>再利用する回数が事前に分かっているなら<code>itertools.tee()</code>を利用する方法もあります。</p>

<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; list = [1, 2, 3]
&gt;&gt;&gt; i = iter(list)
&gt;&gt;&gt; i1, i2, i3 = itertools.tee(i, 3) ← 3回再利用する必要があると仮定
&gt;&gt;&gt; for n in i1:
...     print(n)
...
1
2
3
&gt;&gt;&gt; for n in i1:
...     print(n)
...
&gt;&gt;&gt; for n in i2:
...     print(n)
...
1
2
3
&gt;&gt;&gt; for n in i2:
...     print(n)
...
&gt;&gt;&gt; for n in i3:
...     print(n)
...
1
2
3
&gt;&gt;&gt; for n in i3:
...     print(n)
...
&gt;&gt;&gt;
</code></pre>

<p>ただ、個人的にはこの方法を利用するようなシチュエーションがあまり思い浮かばない・・・。</p>

<h2 id="おわりに">おわりに</h2>

<p>「ん？何で同じ条件なのにループすると空っぽになるんじゃ？」と素朴に思ったのが始まりなのですが、調べてみると案外深い仕様になっていて勉強になりました（小並感）。</p>

<p>ちなみに、複数回ループしようとしてた理由は、原因を調べているうちに忘れました（鳥頭）。</p>
]]></content>
		</item>
		
		<item>
			<title>Vue.jsでデータの内容を開発ツールを使わないで確認する</title>
			<link>https://idontwannawork.github.io/posts/show-data-without-tools/</link>
			<pubDate>Sun, 05 May 2019 17:38:31 +0900</pubDate>
			
			<guid>https://idontwannawork.github.io/posts/show-data-without-tools/</guid>
			<description>小ネタです Vue.jsは、ブラウザの開発ツールやVue.js用の拡張機能を利用しなくても、HTMLファイルにとあるタグを記述することで、デー</description>
			<content type="html"><![CDATA[

<h2 id="小ネタです">小ネタです</h2>

<p>Vue.jsは、ブラウザの開発ツールやVue.js用の拡張機能を利用しなくても、HTMLファイルに<strong>とあるタグ</strong>を記述することで、データの内容をJSON形式で確認できます。</p>

<h3 id="記述方法">記述方法</h3>

<p>HTMLファイル内に「<code>{{ $data }}</code>」を任意の場所に記述します。</p>

<pre><code>&lt;html&gt;
    &lt;head&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;app&quot;&gt;
        &lt;p&gt;{{ message.v }}&lt;/p&gt;
        &lt;p&gt;{{ message.v.length }}&lt;/p&gt;
        &lt;p&gt;{{ l[2] }}&lt;/p&gt;
        &lt;p&gt;{{ l[n] }}&lt;/p&gt;
        &lt;pre&gt;{{ $data }}&lt;/pre&gt;
        &lt;/div&gt;
        &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.13/dist/vue.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>仮にJavaScript側が下記の内容だった場合、</p>

<pre><code>var app = new Vue({
    el: '#app',
    data: {
        message: {
        v: 'Hello Vue World!'
        },
        l: ['hoge', 'ふが', 'ぴyo'],
        n: 1
    }
})
</code></pre>

<p>表示内容は下記の通り。</p>

<p><img src="2019-05-05-17-48-12.png" alt="" /></p>

<p>CodePenでやってみました。</p>

<p><p class="codepen" data-height="265" data-theme-id="0" data-default-tab="html,result" data-user="idontwannawork" data-slug-hash="yrmOOJ" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="vuejs_type">
  <span>See the Pen <a href="https://codepen.io/idontwannawork/pen/yrmOOJ/">
  vuejs_type</a> by idontwannawork (<a href="https://codepen.io/idontwannawork">@idontwannawork</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script></p>

<p>あんまり複雑なデータを出力すると、かえって見にくくなってしまうと思われますが、ちょっとした確認には十分に利用できるかな。</p>
]]></content>
		</item>
		
		<item>
			<title>Pythonのopen関数はencoding引数を指定しよう</title>
			<link>https://idontwannawork.github.io/posts/encode-error-with-open-function/</link>
			<pubDate>Thu, 25 Apr 2019 10:57:12 +0900</pubDate>
			
			<guid>https://idontwannawork.github.io/posts/encode-error-with-open-function/</guid>
			<description>結論 WindowsでPythonのopen関数を使うなら、encoding引数を指定しよう（血涙 何があったのさ WindowsにてPython</description>
			<content type="html"><![CDATA[

<h2 id="結論">結論</h2>

<p>WindowsでPythonのopen関数を使うなら、<strong>encoding引数を指定しよう</strong>（血涙</p>

<h2 id="何があったのさ">何があったのさ</h2>

<p>WindowsにてPythonを用いて、テキストファイルの書き出しと読み込みをしようとしたんです。</p>

<p>そうしたら憎きアイツが出てきたわけです。</p>

<p><img src="2019-04-25-13-12-56.png" alt="pic" /></p>

<p>出たよ、<code>UnicodeDecodeError</code>・・・。</p>

<h2 id="環境">環境</h2>

<ul>
<li>Windows 10</li>
<li>Python 3.6</li>
<li>Visual Studio Code</li>
</ul>

<h2 id="コード">コード</h2>

<pre><code>s = '\x85'
print(s)

with open('C:/app/hoge.txt', mode='w', encoding='utf-8') as f:
    f.write(s)

with open('C:/app/hoge.txt', mode='r') as g:
    print(g.read())        # UnicodeDecodeError`でエラー
</code></pre>

<blockquote>
<p>※問題の部分だけ抜粋しています。本来のソースは入力の文字列がもっとごちゃごちゃしてました。</p>
</blockquote>

<h2 id="原因">原因</h2>

<p>つまるところ、読み込み時の<code>open</code>で引数の<code>encoding</code>を指定していなかったからでした_:(´ཀ`」∠):_</p>

<p>書き出しの際には下記のように<code>encoding</code>を指定していました。</p>

<pre><code>with open('C:/app/hoge.json', mode='w', encoding='utf-8') as f:
</code></pre>

<p>ただ、書き出したファイルを読み込む際に、<code>encoding</code>の指定を失念していました。</p>

<pre><code>with open('C:/app/hoge.json', mode='r') as g:
</code></pre>

<p><code>encoding</code>の指定がない場合については、<a href="https://docs.python.org/ja/3/library/functions.html#open">オフィシャル</a>だと下記のように説明されています。</p>

<blockquote>
<p>encoding が指定されていない場合に使われるエンコーディングはプラットフォームに依存します</p>
</blockquote>

<p>Windowsだと利用されるエンコーディングはCP932です。Pythonから入出力する際、CP932に変換できない文字が存在したため、「変換できないよ！」とエラーになったわけです。</p>

<h2 id="ちなみに">ちなみに</h2>

<p>Python内部では文字列型は<a href="https://docs.python.org/ja/3/library/stdtypes.html#text-sequence-type-str">Unicodeで保持</a>されています。そして、入出力の際はPythonがシステムのエンコーディングに<strong>自動で変換</strong>してくれます。この場合、もともとUTF-8で保持されていたものをCP932に変換します。</p>

<p>この変換をユーザーが意識する必要はありません。逆に言えば、知らない間に<strong>勝手に</strong>変換されます。そして、この自動変換の際に何かしらの「変換できない文字」があるとエラーになる、というわけです。</p>

<h2 id="解消方法">解消方法</h2>

<p>エラーを解消するには、書き出し時と同様に読み込み時にも<code>encoding</code>を指定する必要があります。</p>

<pre><code>with open('C:/app/hoge.json', mode='r', encoding=&quot;utf-8) as f:
    j = json.load(g)
</code></pre>

<p>ちなみに、書き出しの際に<code>encoding</code>を指定しなかった場合も、読み込みと同様にエラーになります。当然っちゃ当然ですね。</p>

<p><img src="2019-04-25-13-13-57.png" alt="pic" /></p>

<p>とりあえず今回は、両方に<code>encoding</code>を指定する方法を取りました。</p>

<h2 id="おわりに">おわりに</h2>

<p><code>encoding</code>を指定のは、手癖にしておくべきだと思いました（小並感</p>

<h2 id="参考文献">参考文献</h2>

<ul>
<li><a href="https://docs.python.org/ja/3.7/index.html">Pythonドキュメント</a></li>
<li><a href="https://qiita.com/butada/items/33db39ced989c2ebf644">(Windows) Python3でのUnicodeEncodeErrorの原因と回避方法</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>json.dumpsでの文字化けを解消する</title>
			<link>https://idontwannawork.github.io/posts/garbled-text-with-json-dumps/</link>
			<pubDate>Wed, 24 Apr 2019 10:38:54 +0900</pubDate>
			
			<guid>https://idontwannawork.github.io/posts/garbled-text-with-json-dumps/</guid>
			<description>概要 Pythonでjson.dumps()した際に、日本語が文字化けするのを防ぐメモ。 環境 Windows 10 Python 3.6 実際のコード &amp;gt;&amp;gt;&amp;gt; import json &amp;gt;&amp;gt;&amp;gt; dic = {&amp;quot;hoge&amp;quot;:&amp;quot;foo&amp;quot;, &amp;quot;fuga&amp;quot;:&amp;quot;bar&amp;quot;, &amp;quot;piyo&amp;quot;:&amp;quot;baz&amp;quot;} &amp;gt;&amp;gt;&amp;gt; json.dumps(dic) &#39;{&amp;quot;hoge&amp;quot;: &amp;quot;foo&amp;quot;, &amp;quot;fuga&amp;quot;: &amp;quot;bar&amp;quot;,</description>
			<content type="html"><![CDATA[

<h2 id="概要">概要</h2>

<p>Pythonで<code>json.dumps()</code>した際に、日本語が文字化けするのを防ぐメモ。</p>

<h2 id="環境">環境</h2>

<ul>
<li>Windows 10</li>
<li>Python 3.6</li>
</ul>

<h2 id="実際のコード">実際のコード</h2>

<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; dic = {&quot;hoge&quot;:&quot;foo&quot;, &quot;fuga&quot;:&quot;bar&quot;, &quot;piyo&quot;:&quot;baz&quot;}
&gt;&gt;&gt; json.dumps(dic)
'{&quot;hoge&quot;: &quot;foo&quot;, &quot;fuga&quot;: &quot;bar&quot;, &quot;piyo&quot;: &quot;baz&quot;}'
&gt;&gt;&gt; dicj = {&quot;日本語&quot;:&quot;項目名&quot;, &quot;にほんご&quot;:&quot;こうもくめい&quot;}
&gt;&gt;&gt; json.dumps(dicj)
'{&quot;\\u65e5\\u672c\\u8a9e&quot;: &quot;\\u9805\\u76ee\\u540d&quot;, &quot;\\u306b\\u307b\\u3093\\u3054&quot;: &quot;\\u3053\\u3046\\u3082\\u304f\\u3081\\u3044&quot;}'
</code></pre>

<p>こんな感じで、単純に<code>json.dumps()</code>すると文字化けしてしまいます。この場合、<code>ensure_ascii</code>オプションで<code>False</code>を指定します。</p>

<pre><code>&gt;&gt;&gt; json.dumps(dicj, ensure_ascii=False)
'{&quot;日本語&quot;: &quot;項目名&quot;, &quot;にほんご&quot;: &quot;こうもくめい&quot;}'
</code></pre>

<p>すると、上記のように文字化けが解消されました。</p>
]]></content>
		</item>
		
		<item>
			<title>Windowsでドット付ファイルを作成する</title>
			<link>https://idontwannawork.github.io/posts/make-file-with-dot-on-windows/</link>
			<pubDate>Mon, 22 Apr 2019 13:06:22 +0900</pubDate>
			
			<guid>https://idontwannawork.github.io/posts/make-file-with-dot-on-windows/</guid>
			<description>結論 ファイル名の冒頭および語尾の両方にドットを付与！ 小ネタです .gitignoreとか.bashrcのように、何かの設定ファイルは冒頭に「.</description>
			<content type="html"><![CDATA[

<h2 id="結論">結論</h2>

<p>ファイル名の冒頭および語尾の両方にドットを付与！</p>

<h2 id="小ネタです">小ネタです</h2>

<p><code>.gitignore</code>とか<code>.bashrc</code>のように、何かの設定ファイルは冒頭に「.（ドット）」が付いて拡張子なしであるような名前だったりします。</p>

<p>ところが、Windowsのexplorer上でドット付のファイルを作成しようとしたらエラーになりました。</p>

<p>たとえば<code>.hoge</code>という名前のファイルを作成しようとします。</p>

<p><img src="2019-04-22-13-09-06.png" alt="alt text" /></p>

<p>こんな名前のファイルを作成しようとすると・・・</p>

<p><img src="2019-04-22-13-09-27.png" alt="alt text" /></p>

<p>エラー！</p>

<h2 id="対策">対策</h2>

<p>そういう場合は、下記のようにファイル名の冒頭および語尾の両方にドットを付与してやるとファイルを作成できます。</p>

<pre><code>.hoge.
</code></pre>

<p><img src="2019-04-22-13-10-14.png" alt="alt text" /></p>

<p>すると・・・</p>

<p><img src="2019-04-22-13-10-28.png" alt="alt text" /></p>

<p>「はい」を押せばドット付ファイルのできあがりです。</p>

<p><img src="2019-04-22-13-11-07.png" alt="alt text" /></p>
]]></content>
		</item>
		
		<item>
			<title>WindowsでLinuxのコマンドが使える「BusyBox」</title>
			<link>https://idontwannawork.github.io/posts/busybox-on-windows/</link>
			<pubDate>Tue, 16 Apr 2019 09:38:26 +0900</pubDate>
			
			<guid>https://idontwannawork.github.io/posts/busybox-on-windows/</guid>
			<description>結論 普段LinuxやMacのシェルで使用している各種コマンドを、Windows環境でも使いたい！となった時には、BusyBoxを使えばいいよ</description>
			<content type="html"><![CDATA[

<h2 id="結論">結論</h2>

<p>普段LinuxやMacのシェルで使用している各種コマンドを、Windows環境でも使いたい！となった時には、<a href="https://BusyBox.net/">BusyBox</a>を使えばいいよ！</p>

<h2 id="はじめに">はじめに</h2>

<p>仕事ではWindows、プライベートではMacまたはLinuxなんて人もいるかもしれません。そこな貴方、こんなシチュエーションがありませんでしょうか？</p>

<blockquote>
<p>ふと仕事中に「<code>grep</code>使いたいなー」とか「<code>awk</code>使いたいなー」とかなっても、Windowsのコマンドプロンプトじゃ足りないし、PowerShellはあの文法がいまいち性に合わない。ガッツリ使うわけじゃないから、わざわざ端末や仮想環境を用意するというわけにもいかない。</p>
</blockquote>

<p>とか、</p>

<blockquote>
<p>Windows使ってるのに普段のMacのノリで<code>ls</code>って入力しちゃって、Windowsに「そんなコマンドないよ」と言われた経験がある。</p>
</blockquote>

<p>そんな貴方（私）のため、BusyBoxが十徳ナイフのごとく活躍してくれます。</p>

<h2 id="この記事の対象者">この記事の対象者</h2>

<p>以下に当てはまる方は、BusyBoxで幸せになれるかもしれません。</p>

<ul>
<li>Windowsを利用しているがUnixのコマンドを使いたい</li>
<li>管理者権限ではなくインストールができない</li>
<li>Hyper-Vなどの仮想環境がない</li>
</ul>

<h3 id="余談1-win10だとlinux使えなかったっけ">（余談1）Win10だとLinux使えなかったっけ？</h3>

<p>Windows 10だとWSL（Windows Subsystem for Linux）で、UbuntuなどのLinuxディストリビューションを利用できます・・・が、リリースモデルの1つ、Enterprise LTSC（Long Term Servicing Channel）だとWSLが利用できません。企業によっては、「安定性などを確保するために、OSに対する頻繁な変更は行いたくない」場合、このモデルが採用されている可能性があります。</p>

<p>この場合も、やっぱりBusyBoxの出番です。</p>

<blockquote>
<p>※以前は「Long Term Servicing Branch（LTSB）」という名前でリリースされていましたが、現在は「Long Term Servicing Channel（LTSC）」に名称変更されました。</p>
</blockquote>

<h3 id="余談2-cygwinとかじゃダメなの">（余談2）Cygwinとかじゃダメなの？</h3>

<p>ダメじゃないです、全然大丈夫です。ただ、「ちょっと<code>sed</code>使いたいなー」っていう場合には、機能てんこ盛りなCygwinだとオーバースペックだったりします。</p>

<p>VMwareなどの仮想環境が利用できるなら、そっちの方がいろいろ便利です。ただ、マシンスペックがイマイチだったり記憶容量があまりない場合は却ってストレスになるでしょうし、やっぱりちょっとだけ使うという用途に対してオーバースペックと言わざるを得ません。</p>

<h2 id="インストール">インストール</h2>

<ol>
<li><a href="https://BusyBox.net/">サイト</a>からバイナリをダウンロードして、任意のフォルダーにて展開する。</li>
<li>展開したフォルダーを環境変数に登録する（利用するだけなら必須ではないけど、登録しておくと後が楽）。</li>
</ol>

<p>終わりです。ダウンロードして展開すればいい実行ファイルなので、インストール権限は必要ないです。しかもめちゃくちゃ軽量なので、記憶容量をガツガツ食っちゃうこともありません。</p>

<p>なお、ソースもダウンロードが可能ですが、あまりニーズはないだろうと判断し、この記事の中では触れません。</p>

<h2 id="使い方">使い方</h2>

<h3 id="とりあえず実行してみる">とりあえず実行してみる</h3>

<p><code>BusyBox64.exe</code>と入力して実行してみます。</p>

<pre><code>C:\hoge&gt;BusyBox64.exe
BusyBox v1.31.0-FRP-2910-ge92596d0b (2019-01-10 14:16:45 GMT) multi-call binary
(mingw64-gcc 8.2.0-3.fc29; mingw64-crt 5.0.4-2.fc29)

BusyBox is copyrighted by many authors between 1998-2018.
Licensed under GPLv2. See source distribution for detailed
copyright notices.

Usage: BusyBox [function [arguments]...]
  or: BusyBox --list[-full]
  or: BusyBox --install [DIR]
  or: BusyBox --uninstall [-n] file
  or: function [arguments]...

        BusyBox is a multi-call binary that combines many common Unix
        utilities into a single executable.  The shell in this build
        is configured to run built-in utilities without $PATH search.
        You don't need to install a link to BusyBox for each utility.
        To run external program, use full path (/sbin/ip instead of ip).

Currently defined functions:
        [, [[, ar, arch, ash, awk, base64, basename, bash, bunzip2, BusyBox, bzcat, bzip2, cal, cat, chmod, cksum,
        clear, cmp, comm, cp, cpio, cut, date, dc, dd, df, diff, dirname, dos2unix, dpkg-deb, du, echo, ed, egrep, env,
        expand, expr, factor, false, fgrep, find, fold, fsync, ftpget, ftpput, getopt, grep, groups, gunzip, gzip, hd,
        head, hexdump, iconv, id, ipcalc, kill, killall, less, link, ln, logname, ls, lzcat, lzma, lzop, lzopcat, man,
        md5sum, mkdir, mktemp, mv, nc, nl, od, paste, patch, pgrep, pidof, pipe_progress, pkill, printenv, printf, ps,
        pwd, realpath, rev, rm, rmdir, rpm, rpm2cpio, sed, seq, sh, sha1sum, sha256sum, sha3sum, sha512sum, shred,
        shuf, sleep, sort, split, ssl_client, stat, strings, sum, tac, tail, tar, tee, test, timeout, touch, tr, true,
        truncate, ttysize, uname, uncompress, unexpand, uniq, unix2dos, unlink, unlzma, unlzop, unxz, unzip, usleep,
        uudecode, uuencode, vi, watch, wc, wget, which, whoami, whois, xargs, xxd, xz, xzcat, yes, zcat
</code></pre>

<p>利用方法や利用可能なコマンドが表示されます。<code>awk</code>や<code>find</code>、<code>grep</code>など一般的なコマンドを利用できることがわかります。</p>

<h3 id="コマンドの実行方法">コマンドの実行方法</h3>

<p>コマンドプロンプトを立ち上げ、下記のように入力し実行します。</p>

<pre><code>BusyBox64.exe 実行したいコマンド
</code></pre>

<p>プロセスを参照したければ<code>ps</code>を実行するわけですが、その場合は下記のように入力して実行します。</p>

<pre><code>BusyBox64.exe ps
</code></pre>

<p>この場合、「BusyBox使って<code>ps</code>を実行するぜ」と言っていることになります。</p>

<p>なお、オプションを利用してコマンド発行するのも普段と同様です。</p>

<pre><code>BusyBox64.exe ls -la
</code></pre>

<p>このように入力して実行すれば<code>l</code>と<code>a</code>のオプションが有効になります。</p>

<h3 id="毎回busyboxって入力しなきゃいけないの">毎回BusyBoxって入力しなきゃいけないの？</h3>

<p>もちろん、そんなことはないです。ログインシェルとして利用することも可能です。その場合のコマンドは下記の通りです。</p>

<pre><code>BusyBox64.exe sh -l
</code></pre>

<h3 id="実行時の注意">実行時の注意</h3>

<p>前述の通り、BusyBoxはログインシェルとしても利用できます。ただし、コマンドによっては管理者権限が要求されているようで、「Permission Denied」と言われ実行できないケースがありました。自分が実行した際は、<code>grep</code>でこの症状が出ました。</p>

<p>そうなれば管理者権限を付与した状態でシェルを起動すればいい、ということになりますが、毎回「スタートボタンで右クリックしてコマンドプロンプトを管理者権限で実行してから<code>BusyBox sh -l</code>を実行してシェル起動」するのは鬱陶しいので、最初から権限を付与して起動することにしました。</p>

<pre><code>powershell start-process BusyBox64.exe -verb runas 'sh -l'
</code></pre>

<p>上記コマンドを、batファイルなどにするかエイリアス設定してやればいいわけです。自分は、個人用に作成したランチャーで上記のコマンドを実行しています。</p>
]]></content>
		</item>
		
		<item>
			<title>Pythonの命名規約</title>
			<link>https://idontwannawork.github.io/posts/python-naming-conventions/</link>
			<pubDate>Fri, 12 Apr 2019 15:27:02 +0900</pubDate>
			
			<guid>https://idontwannawork.github.io/posts/python-naming-conventions/</guid>
			<description>命名規約のメモ PEP8に準拠。何番煎じかわからないけども自学用に。 推奨される命名規約 命名対象 ルール 例 備考 パッケージ、モジュール すべて小文字で</description>
			<content type="html"><![CDATA[

<h2 id="命名規約のメモ">命名規約のメモ</h2>

<p><a href="https://www.python.org/dev/peps/pep-0008/">PEP8</a>に準拠。何番煎じかわからないけども自学用に。</p>

<h3 id="推奨される命名規約">推奨される命名規約</h3>

<table>
<thead>
<tr>
<th align="center">命名対象</th>
<th align="center">ルール</th>
<th align="center">例</th>
<th align="center">備考</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">パッケージ、モジュール</td>
<td align="center">すべて小文字で短く</td>
<td align="center">flask, os</td>
<td align="center">アンダースコアの利用は非推奨</td>
</tr>

<tr>
<td align="center">クラス</td>
<td align="center">（アッパー）キャメルケース</td>
<td align="center">MyClass</td>
<td align="center"></td>
</tr>

<tr>
<td align="center">型変数</td>
<td align="center">（アッパー）キャメルケース</td>
<td align="center">MyClass</td>
<td align="center"></td>
</tr>

<tr>
<td align="center">例外</td>
<td align="center">（アッパー）キャメルケース、最後に「Error」</td>
<td align="center">MyExcepError</td>
<td align="center">例外はクラスであるべき、とのこと</td>
</tr>

<tr>
<td align="center">グローバル変数</td>
<td align="center">すべて小文字でアンダースコア区切り、2つアンダースコアを付与</td>
<td align="center"><code>__all__</code></td>
<td align="center">グローバル変数をエクスポートするのを防ぐ</td>
</tr>

<tr>
<td align="center">関数、変数</td>
<td align="center">すべて小文字でアンダースコア区切り</td>
<td align="center">my_funcion</td>
<td align="center"></td>
</tr>

<tr>
<td align="center">メソッド、インスタンス変数</td>
<td align="center">すべて小文字でアンダースコア区切り</td>
<td align="center">my_method</td>
<td align="center"></td>
</tr>

<tr>
<td align="center">定数</td>
<td align="center">すべて大文字でアンダースコア区切り</td>
<td align="center">MY_CONST</td>
<td align="center"></td>
</tr>
</tbody>
</table>

<h3 id="ポピュラーな命名">ポピュラーな命名</h3>

<p>上記の基本的なルールに準拠して、実際にはどんな感じで命名をされているか、について。</p>

<h4 id="1文字のみ">1文字のみ</h4>

<pre><code>b
</code></pre>

<p>小文字1文字。</p>

<pre><code>B
</code></pre>

<p>大文字1文字。</p>

<h4 id="複数文字列">複数文字列</h4>

<pre><code>lowercase
</code></pre>

<p>または</p>

<pre><code>lower_case_with_underscores
</code></pre>

<p>小文字たちとアンダースコア。</p>

<pre><code>UPPERCASE
</code></pre>

<p>または</p>

<pre><code>UPPER_CASE_WITH_UNDERSCORES
</code></pre>

<p>大文字たちとアンダースコア。</p>

<h4 id="その他">その他</h4>

<pre><code>CapitalizedWords
</code></pre>

<p>キャメルケース。</p>

<pre><code>Capitalized_Words_With_Underscores
</code></pre>

<p>大文字小文字とアンダースコア。ただし、これはPEP8の<a href="https://www.python.org/dev/peps/pep-0008/#descriptive-naming-styles">命名に関するドキュメント</a>中でも「いまいち」扱いされている。</p>

<pre><code>Capitalized_Words_With_Underscores (ugly!)
</code></pre>
]]></content>
		</item>
		
	</channel>
</rss>
