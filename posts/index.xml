<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Come as you are</title>
		<link>https://idontwannawork.github.io/posts/</link>
		<description>Recent content in Posts on Come as you are</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>ja</language>
		<lastBuildDate>Mon, 10 Jun 2019 00:52:30 +0900</lastBuildDate>
		<atom:link href="https://idontwannawork.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>VS CodeでDockerコンテナーのPython開発環境にリモート接続する</title>
			<link>https://idontwannawork.github.io/posts/connect-to-docker-with-vscode-extension/</link>
			<pubDate>Mon, 10 Jun 2019 00:52:30 +0900</pubDate>
			
			<guid>https://idontwannawork.github.io/posts/connect-to-docker-with-vscode-extension/</guid>
			<description>はじめに Visual Studio Code（以下、vscode）を使って、Dockerのコンテナー上にある開発環境へリモートで接続します。このとき、ptvsdでは</description>
			<content type="html"><![CDATA[

<h2 id="はじめに">はじめに</h2>

<p>Visual Studio Code（以下、vscode）を使って、Dockerのコンテナー上にある開発環境へリモートで接続します。このとき、<a href="https://github.com/microsoft/ptvsd">ptvsd</a>ではなく、vscodeの拡張機能である<a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers">Remote</a>を用いて接続します。</p>

<h2 id="環境構築">環境構築</h2>

<h3 id="環境">環境</h3>

<ul>
<li>macOS Mojave 10.14.5</li>
<li>Docker version 18.09.2</li>
<li>Visual Studio Code version 1.35</li>
</ul>

<h3 id="拡張機能">拡張機能</h3>

<p>まずは何はなくとも下記の拡張機能をインストールします。</p>

<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers">Remote - Containers</a></li>
</ul>

<p><img src="2019-06-09-19-47-16.png" alt="pic" /></p>

<p>RemoteはまだvscodeのInsider版でしか動作しなかった・・・のですが、6月6日にStable版でも対応しました。</p>

<h2 id="接続手順">接続手順</h2>

<p>基本的な手順は<a href="https://code.visualstudio.com/docs/remote/containers#_quick-start-try-a-dev-container">ここ</a>にあるものを参考にしています。</p>

<ol>
<li><p>Dockerアイコンをクリックして、メニュー中の「Preferences」をクリック。「File Sharing」を選択して、共有したいディレクトリが設定されているか確認する。</p>

<p><img src="2019-06-09-19-55-27.png" alt="pic" /></p>

<p>Dockerのメニュー中にPreferencesがあるはずなので、これをクリック。</p>

<p><img src="2019-06-09-19-56-03.png" alt="pic" /></p>

<p>表示されたディレクトリのうち、共有したいディレクトリが設定されていることを確認しておきます。</p></li>

<li><p>任意のコンテナーを準備します。今回はPython用のサンプルプロジェクトを<a href="https://github.com/microsoft/vscode-remote-try-python">microsoftが準備している</a>ので、これをcloneしました。</p>
<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">~/devp  git clone https://github.com/microsoft/vscode-remote-try-python.git
Cloning into &#39;vscode-remote-try-python&#39;...
remote: Enumerating objects: 94, done.
remote: Counting objects: 100% (94/94), done.
remote: Compressing objects: 100% (70/70), done.
remote: Total 94 (delta 47), reused 51 (delta 18), pack-reused 0
Unpacking objects: 100% (94/94), done.</code></pre></div>
<p>ちなみに<a href="https://github.com/microsoft/vscode-remote-try-go">Golang用</a>やいろんな言語があったりします。</p>

<p>ただし、現在（2019年5月30日）のところAlpine LinuxやWindowsベースのコンテナーは<a href="https://code.visualstudio.com/docs/remote/containers#_getting-started">サポート外</a>とのこと。</p>

<blockquote>
<p>Note: Alpine Linux and Windows based dev containers are not currently supported.</p>
</blockquote></li>

<li><p>cloneした資産を拡張機能のRemoteで開きます。</p>

<p>vscodeを起動します。起動したら、vscodeの左下にある「&gt;&lt;」みたいな部分をクリックします。このとき、先ほどcloneしたディレクトリを開く必要はありません。</p>

<p><img src="2019-06-09-21-05-44.png" alt="pic" /></p>

<p>すると、vscode上部に4つほどコマンドがリストで表示されます。その中から<code>Remote-Containers: Open Folder in Container...</code>を選択します。</p>

<p><img src="2019-06-09-21-07-42.png" alt="pic" /></p>

<p>ディレクトリを選択するダイアログが表示されるので、先ほどcloneしたディレクトリを選択します。</p>

<p>ディレクトリを選択すると、画面がリロードされます。このとき、初回起動でコンテナーが存在していない場合はvscodeが自動的に生成します。しばらく待って、右下の「処理中」メッセージが消えたら準備完了です。</p>

<p><img src="2019-06-09-21-12-03.png" alt="pic" /></p>

<p>とりあえずこの時点で、パッと見はあまり普段と変化は感じられませんが・・・。</p>

<p><img src="2019-06-09-21-21-57.png" alt="pic" /></p>

<p>左下の部分を見ると「Dev Container: Python Sample」と表示されており、コンテナーに接続していることがわかります。</p>

<p><img src="2019-06-09-21-24-28.png" alt="pic" /></p>

<p>この状態でターミナルを起動し<code>docker ps</code>してみると、下記のようにコンテナーが起動していることがわかります。</p>
<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">~ ❯❯❯ docker ps
CONTAINER ID        IMAGE                                                           COMMAND                  CREATED             STATUS              PORTS                      NAMES
3afa6cb8f1e2        vsc-vscode-remote-try-python-f50dab769712249e3a925e9d880f74de   &#34;/bin/sh -c &#39;echo Co…&#34;   6 minutes ago       Up 6 minutes        127.0.0.1:9000-&gt;9000/tcp   nervous_dirac</code></pre></div>
<p>こんな手順を踏めば、Dockerのコンテナー上で動作している開発環境にvscodeで接続できます。</p></li>
</ol>

<h2 id="デバッグしてみる">デバッグしてみる</h2>

<p>とりあえず接続はできたわけなので、今度は実際に動作確認とデバッグをしてみます。</p>

<p>コンテナーに接続しているvscode上でTERMINALタブを開きます。まずは、プロンプトが接続先のコンテナーであることを確認します。</p>
<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">root@3afa6cb8f1e2:/workspaces/vscode-remote-try-python# uname
Linux</code></pre></div>
<p>本来、macOSのターミナルで<code>uname</code>を実行した場合は「Darwin」と返ってくるので、「Linux」と返ってくるならmacOSのそれではなくコンテナー上のプロンプトであると判断できます。</p>

<p>ここでデバッグが可能か確認するために、app.pyのソースで任意の行にブレークポイントを設定します。ちなみに、すでにvscodeのデバッグメニューを見てみると、<code>Flask</code>で設定済みだったりします。これはclone元ですでにlaunch.jsonが作成済みだからです。親切！</p>

<p><img src="2019-06-09-23-24-34.png" alt="pic" /></p>

<p>この状態で<code>F5</code>キーを押します。あるいはデバッグメニューから「Start Debugging」をクリックします。すると、コンテナーのプロンプトでPythonが実行され、下記のようなメッセージが表示されてFlaskが起動します。</p>
<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">※実行コマンドは省略
 * Serving Flask app &#34;app.py&#34;
 * Environment: development
 * Debug mode: off
 * Running on http://0.0.0.0:9000/ (Press CTRL+C to quit)</code></pre></div>
<p>ブラウザを起動してローカルホストに9000ポートで接続します。この際、先ほど設定したブレークポイントで処理が一時的に停止するはずです。この状態では、ローカルで開発しているときと同様に変数値のチェックなどができます。vscodeはコンテナーにリモート接続していますが、それを意識することなく普段どおりの使い方が可能です。</p>

<p>ブレークポイントで停止している処理を続行してやれば、ブラウザがwebページを表示します。</p>

<p><img src="2019-06-10-00-03-10.png" alt="pic" /></p>

<p>これで動作確認とデバッグができました。</p>

<p>なお、実行を止めたい場合はいつもどおり<code>Shift + F5</code>を押せば止まります。</p>

<p>ちなみに、vscodeを終了するとコンテナーは自動的に停止します。<code>docker ps</code>で確認すると表示されなくなっているはずです。</p>

<h2 id="コンテナー設定を変更したらリビルドする">コンテナー設定を変更したらリビルドする</h2>

<p>コンテナーの設定を変更した場合は、vscodeの左下をクリックしてコマンドの一覧を表示します。</p>

<p><img src="2019-06-10-00-09-16.png" alt="pic" /></p>

<p>表示された一覧の中から<code>Remote Containers: Rebuild Container</code>を選択します。</p>

<p><img src="2019-06-10-00-10-13.png" alt="pic" /></p>

<p>画面がリロードされてコンテナーが再度ビルドされます。</p>

<h2 id="まとめ">まとめ</h2>

<p>Dockerをインストールして、vscodeを導入し拡張機能のRemoteをインストールすれば、もうあとは欲しい環境をコンテナーで用意するだけで開発環境が揃います。ローカルに開発のための環境を用意する必要がないので、下手にローカル環境を汚すこともなくなります。</p>

<p>ベタなセリフですが、すごい時代になったものです、ホントに。</p>
]]></content>
		</item>
		
		<item>
			<title>macOSアップデート後のxcrunエラーはxcodeをインストールする</title>
			<link>https://idontwannawork.github.io/posts/xcrun-error-after-macos-update/</link>
			<pubDate>Sun, 09 Jun 2019 19:29:47 +0900</pubDate>
			
			<guid>https://idontwannawork.github.io/posts/xcrun-error-after-macos-update/</guid>
			<description>macOSあるある？ macOSのアップデート（High SierraからMojave）後にgitを実行するとxcrunが見つからないよ！という</description>
			<content type="html"><![CDATA[

<h2 id="macosあるある">macOSあるある？</h2>

<p>macOSのアップデート（High SierraからMojave）後にgitを実行すると<code>xcrun</code>が見つからないよ！というエラー内容が出現しました。</p>

<p>経験上このエラーメッセージが出現するのってmacOSのアップデート直後なんですよね・・・。そんなわけで毎度調べるのもアレなのでメモしておきます。</p>

<h2 id="エラー内容">エラー内容</h2>

<p>macOSをアップデートした際に、gitを実行しようとすると下記のようなエラーになることがあります。</p>

<pre><code>~ ❯❯❯ git
xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun
</code></pre>

<p>他のコマンドでも同じようなエラーメッセージが出現するのかな？</p>

<h2 id="解消法">解消法</h2>

<p>下記のコマンドを発行します。</p>

<pre><code>xcode-select --install 
</code></pre>

<p>「インストールしますか？」という旨のメッセージが表示されたらOKします。インストールは十数秒で終わると思います。インストールが終わればgitは使えるようになります。</p>
]]></content>
		</item>
		
		<item>
			<title>TASCAMのiXZを使ってiPhoneでレコーディングする</title>
			<link>https://idontwannawork.github.io/posts/recocrd-with-tascam-ixz/</link>
			<pubDate>Tue, 04 Jun 2019 17:11:23 +0900</pubDate>
			
			<guid>https://idontwannawork.github.io/posts/recocrd-with-tascam-ixz/</guid>
			<description>そもそもiXZって何ぞや TASCAMが販売しているスマートフォン・タブレット端末用オーディオインターフェイスです。発売は2011年とめちゃく</description>
			<content type="html"><![CDATA[

<h2 id="そもそもixzって何ぞや">そもそもiXZって何ぞや</h2>

<p><img src="IMG_0671.png" alt="pic" /></p>

<p><a href="https://tascam.jp/jp/product/ixz/top">TASCAMが販売している</a>スマートフォン・タブレット端末用オーディオインターフェイスです。発売は2011年とめちゃくちゃ昔なのですが現役で販売されていることからもわかる通り、スマートフォン・タブレット端末で利用できる手軽なインターフェイスの王道です。</p>

<p>特徴としては、スマートフォンなどに「アナログで接続する」という点。そして、ギター専用の<a href="https://www.ikmultimedia.com/products/irig2/?L=JP">iRig</a>のような「スマートフォンに直接接続する」仕様であるにもかかわらず、ギターだけじゃなくコンデンサーマイクの利用も可能な点でしょうか。</p>

<h2 id="仕様">仕様</h2>

<p><img src="IMG_0679.png" alt="pic" /></p>

<p>サイズは<code>106（W）× 40（H）× 45（D）mm</code>と、最近大型化しているスマートフォンと比べると厚さ以外は割とコンパクト。単3電池2本がセット可能ですが、電池を含めないと100gを切るくらいの軽量さ。</p>

<p>入力端子はハイインピーダンス入力に対応していて、ギターなどを直接接続できます。また、端子がXLR/TSコンボジャック仕様で、ギター・ベースやシンセサイザーなどの標準プラグだけでなく、XLR端子をもつマイクも接続可能です。さらに、単3電池2本によるファントム電源の供給が可能で、コンデンサーマイクの接続もできるとあって、実売価格が4000円前後の商品としては割と充実した装備です。</p>

<p>スマートフォンやタブレットへの接続には、本体から「ニョキッ」と生えている4極端子を用います。デバイスのヘッドホン端子に接続することで、アナログでのレコーディングができるようになるわけです。最近だとLightning端子などに接続してデジタルでレコーディングする機種もありますが、ヘッドホン端子でのアナログ接続ならAndroidとiOSの双方で利用できるので、ありがたいです。まぁ、最近はそもそも<a href="https://www.apple.com/jp/iphone-xs/">ヘッドホン端子</a>が<a href="https://www.apple.com/jp/iphone-xr/">存在しないスマホ</a>も<a href="https://www.nttdocomo.co.jp/product/smart_phone/so01l/">ゴロゴロ</a>ありますけどね・・・。</p>

<p>ちなみに、説明書などにはこの機種が利用できるデバイスを「4極端子（CTIA規格）を搭載した端末に限ります」としているのですが、4極端子を装備していないデバイスって最近あるんですかね？</p>

<p>また、本体背面の3.5mmステレオミニジャックにイヤホンやヘッドホンを接続することで、音声出力をモニターしながらレコーディングできます。まぁ、この「モニターしながらレコーディングできる」って言うのが、<strong>ちょっとした罠</strong> になっているんですけどね・・・_(┐「ε:)_（後述）</p>

<p>なお、当機種はiOSにおける動作検証の対象機材となっており<a href="https://tascam.com/jp/support/news/5751">サポートページ</a>でiOS12における動作が確認されていることから、今後もしばらくは安心して使用できます。ただ、Lightning端子に接続するようなデジタル仕様じゃないので、OSの変更で影響が出てくるのか？と問われると、「ぶっちゃけ関係ないんじゃないの？」と首をかしげるところではありますが。</p>

<p>ちなみに、細かいところにツッコミを入れるなら、多分USBオーディオインターフェイスじゃないと思うんですけど（名推理）</p>

<p><img src="2019-06-04-17-36-25.png" alt="pic" /></p>

<h2 id="使い方">使い方</h2>

<h3 id="接続">接続</h3>

<p>使い方は、正面の入力端子にギターやシンセを接続し、背面の4極ミニプラグケーブルをスマートフォンやタブレットのヘッドホンを接続します。また、本体の背面にあるヘッドホン端子へ対しヘッドホンなどを接続して音声出力をモニターします。</p>

<p><img src="2019-06-04-18-09-02.png" alt="pic" /></p>

<p>このとき、標準ジャックを利用するのであれば電池は不要です。電池は、コンデンサーマイクを接続する際のファントム電源の供給にのみ利用するからです。</p>

<h3 id="音量調整">音量調整</h3>

<p>音量はデバイスのボリュームを調整することで操作します。</p>

<h3 id="さあレコーディング-あれ">さあレコーディング！・・・あれ？</h3>

<p>接続はこれで終わりです。ただこれだけではレコーディングできません。そう、<strong>アプリ</strong>が必要なのですよ・・・！</p>

<h3 id="アプリは">アプリは？</h3>

<p>iXZ用のアプリというものはリリースされていません。じゃあどうするか？</p>

<p><strong>好きなアプリを使えばいいんじゃね？</strong>、です。</p>

<p>そう言ってしまうと冗談に聞こえますが割とマジです。何せアナログの入力なので、プロテクトも何もないわけですから、極端なことを言えばスマホに標準搭載されているカメラアプリを使って録画してもいいわけです。あるいは、iOSであれば<a href="https://www.apple.com/jp/ios/garageband/">GarageBand</a>がパッと思い浮かぶところでしょうか。</p>

<p><strong>慣れ親しんだアプリを使ってね</strong>という、TASCAMの思いやりなのかもしれないデスネ（ぐるぐる目）</p>

<h2 id="つまづいたところ">つまづいたところ</h2>

<p>単純明快なアナログ接続のiXZですが、スムーズに万事うまく行ったわけではありませんでした。というのが、<strong>音声入力のモニターができるか否かはアプリに依存</strong>する点です。</p>

<p>当初、この機種の動作確認を行うのに、iPhoneのカメラアプリを利用しました。ところが、接続したイヤホンから音声のモニターができないのです。かすかな「サー」というホワイトノイズが彼方に聞こえるのみで、INPUTのダイヤルをひねろうとiPhoneの音量を調整しようと一向に音声をモニターできません。</p>

<p>「あちゃー、初期不良かなー」と思いましたが、録画した動画を再生してみるとしっかりと入力した音声が録画されていました。<strong>つまり、音声入力は取得できているけど、それをモニターできない</strong>わけでした。</p>

<p>少し調べてみたところ「モニターの可否は、レコーディングに利用するアプリが<strong>入力された音声を出力へ返してくれるかどうか</strong>に依存している」ということがわかりました。</p>

<p>つまり、iXZは録音するデバイス（この場合iPhone）からの音声出力を単純にイヤホンに出力しているだけで、iXZ本体でイヤホンジャックに向けて配線しているわけではない、ということです。なので、モニタリングできるよう入力された音声を出力できるようなアプリを利用すればよい、ということになります。</p>

<p>ただし、GarageBandのようなアプリは動画ではなく音声のみを録音するので、「動画を取りつつ音声をモニターしたい」というニーズには残念ながら大抵のアプリが非対応、ということになります。</p>

<p>この場合、根本的な解決策はモニターできる録画アプリを探すことになります。が、今回は録画したかったものがKORGのvolcaをいじる場面だったので、ステレオミニプラグを分岐させるアダプターを利用しました。volcaのアウトプットに分岐アダプターを接続し、一方はiXZに接続しつつもう一方をイヤホンやスピーカーに接続することで、モニターしながら録画できる環境にしました。</p>

<h2 id="使った感じはどうなのよ">使った感じはどうなのよ？</h2>

<p><strong>スゲーお手軽・・・！！</strong> _(┐「ε:)_</p>

<p>これなんですよねぇ。レコーディングしたい機材をパパッと接続して、アプリを起動して録音するだけ。それ以上の操作は必要ないうえ、どこへでも持って行けるサイズ。ギターなどを接続するなら電池も不要で、とにかく身軽かつ気軽。</p>

<p>アナログ特有のノイズはどうしてもありますが、言うほど気にはなりません。これ以上を望むならもう少し出費してデジタルのオーディオインターフェイスを準備するほうが、精神衛生上よろしいかと思います。</p>

<p>というか、この手のインターフェイスでギターとマイクが接続できるものはiXZが今の所最安値です。より良い環境を求めるなら自動的に出費する以外にはありません。強いて言えばiRigですけど、あれはギターとかの標準プラグのみ対応してる機種ですしね。</p>

<p>気になったと言えば、iXZ本体にイヤホンを接続してモニターする場合、原音と比べて若干音がマイルドになるというか、少しハリがなくなるというか、そんな気がします。良く言えば「角が取れて落ち着く」、悪く言えば「ヌケが悪くなってダルい」。ただし、イヤホンはあくまでもモニター用ですしiPhone本体にはそこそこのヌケで録音されているので問題ないでしょう。</p>

<p>そして何よりこの値段設定が素晴らしい。コストパフォーマンスとしては、100点満点じゃないでしょうか。</p>

<h2 id="まとめ">まとめ</h2>

<p><strong>身軽でお手軽な上、コスパまで備えた働き者</strong>です。</p>

<p>スマートフォンやタブレットを利用してレコーディングしたい、ギターだけじゃなくてマイクも使いたい、小難しいのはいいからとにかく気軽にやりたい。</p>

<p>そんな人にぜひオススメしたい、良質なインターフェイスです。</p>
]]></content>
		</item>
		
		<item>
			<title>PythonでMarkdownファイルをHTMLへ変換する</title>
			<link>https://idontwannawork.github.io/posts/convert-markdown-to-html-with-python/</link>
			<pubDate>Fri, 24 May 2019 14:50:30 +0900</pubDate>
			
			<guid>https://idontwannawork.github.io/posts/convert-markdown-to-html-with-python/</guid>
			<description>はじめに 以前、VS CodeでMarkdownをPDFに自動で変換する方法を書いたのだけど、今度はHTMLファイルに変換する必要が出てきたので</description>
			<content type="html"><![CDATA[

<h2 id="はじめに">はじめに</h2>

<p>以前、<a href="/posts/convert-markdown-to-pdf-with-vscode/">VS CodeでMarkdownをPDFに自動で変換する</a>方法を書いたのだけど、今度はHTMLファイルに変換する必要が出てきたので勉強がてら、Pythonで書くことにしました。と言っても難しい処理では全然ないんだけど・・・_(┐「ε:)_</p>

<p>ちなみに、<a href="/posts/convert-markdown-to-pdf-with-vscode/">前の記事</a>で紹介した拡張機能<a href="https://marketplace.visualstudio.com/items?itemName=yzane.markdown-pdf">Markdown PDF</a>を使えばHTMLにも変換できます。ただ、今回はVS Codeがないというシチュエーションでファイル変換したいのと、自分が作成したスタイルシートでHTMLファイルを生成したかったため、VS Codeの拡張機能を頼らない方法を取りました。</p>

<p>というわけで、Pythonを使ったMarkdownファイルをHTMLへ変換する手順について書きます。</p>

<h2 id="リポジトリ">リポジトリ</h2>

<p><a href="https://github.com/idontwannawork/markdowntohtml">こちら</a>にソースコード一式を置いてあります。</p>

<h2 id="環境">環境</h2>

<ul>
<li>Python ※3.x系</li>
<li>Markdown</li>
</ul>

<p><a href="https://python-markdown.github.io/">Markdown</a>は事前に<code>pip</code>しておく。</p>
<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">pip install Markdown</code></pre></div>
<p>一応プラットフォームに関しては、MacやWindowsに限らず動作する・・・はず_(┐「ε:)_</p>

<h2 id="概要">概要</h2>

<p>フォルダ中に存在するmdファイルを取得して、HTMLファイルに変換します。</p>

<h2 id="詳細">詳細</h2>

<h3 id="ファイル">ファイル</h3>

<ul>
<li><p>mdtohtml.py</p>

<p>Pythonで記述された本体。実行の際は当ファイルを指定します。</p></li>

<li><p>style.css</p>

<p>CSSが書かれたファイル。生成されたHTMLファイルに<code>&lt;style&gt;</code>タグで記述されます。スタイルの変更を行いたい場合、当ファイルを書き換えてHTMLを生成してください。</p></li>
</ul>

<h3 id="使い方">使い方</h3>

<ol>
<li><p>変換したいmdファイルがあるフォルダに上記の2ファイルを配置します。</p>
<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">$ ls
README.md    iamacat.md   main.css     mdtohtml.py</code></pre></div></li>

<li><p>配置したら、そのフォルダにて下記のコマンドを実行します。</p>
<div class="highlight"><pre class="chroma"><code class="language-console" data-lang="console">$ python mdtohtml.py
iamacat.md の変換を開始します
-----------------------------------
iamacat.md を iamacat.html へ変換しました
README.md の変換を開始します
-----------------------------------
README.md を README.html へ変換しました
$ ls
README.html   README.md     iamacat.html  iamacat.md    main.css      mdtohtml.py</code></pre></div></li>
</ol>

<h3 id="処理内容">処理内容</h3>

<p>実行されたフォルダ中に存在するmdファイルを取得して、HTMLファイルに変換して同じフォルダーに出力します。mdファイルが複数ある場合は、すべてHTML化します。</p>

<h2 id="コード">コード</h2>

<p>基本的には、HTML化はMarkdownに丸投げしています。丸投げした後、必要な<code>&lt;html&gt;</code>タグなどを付与しているだけです。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">markdown</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">glob</span>

<span class="c1"># Markdown拡張</span>
<span class="n">mdextensions</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;tables&#34;</span><span class="p">]</span>


<span class="c1"># mdファイルの変換</span>
<span class="k">def</span> <span class="nf">convertHtml</span><span class="p">(</span><span class="n">mdpath</span><span class="p">,</span> <span class="n">htmlpath</span><span class="p">,</span> <span class="n">style</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">mdpath</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&#34;utf-8&#34;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="c1"># Markdown の import 文を除去</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;@import &#34;.+&#34;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="c1"># HTMLに変換</span>
        <span class="n">body</span> <span class="o">=</span> <span class="n">markdown</span><span class="o">.</span><span class="n">Markdown</span><span class="p">(</span><span class="n">extensions</span><span class="o">=</span><span class="n">mdextensions</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

        <span class="n">html</span> <span class="o">=</span> <span class="s1">&#39;&lt;html lang=&#34;ja&#34;&gt;&lt;meta charset=&#34;utf-8&#34;&gt;&#39;</span>
        <span class="n">html</span> <span class="o">+=</span> <span class="s1">&#39;&lt;style&gt;&#39;</span> <span class="o">+</span> <span class="n">style</span> <span class="o">+</span> <span class="s1">&#39;&lt;/style&gt;&#39;</span>
        <span class="n">html</span> <span class="o">+=</span> <span class="s1">&#39;&lt;body&gt;&#39;</span> <span class="o">+</span> <span class="n">body</span> <span class="o">+</span> <span class="s1">&#39;&lt;/body&gt;&lt;/html&gt;&#39;</span>

        <span class="c1"># HTMLで出力</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">((</span><span class="n">htmlpath</span><span class="p">),</span> <span class="s2">&#34;w&#34;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&#34;utf-8&#34;</span><span class="p">)</span> <span class="k">as</span> <span class="n">g</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="c1"># スタイルは、style.cssを参照する</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;./style.css&#39;</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&#34;utf-8&#34;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">style</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">mdfile</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&#34;*.md&#34;</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&#34;</span><span class="si">%s</span><span class="s2"> の変換を開始します&#34;</span> <span class="o">%</span> <span class="n">mdfile</span><span class="p">)</span>
            <span class="n">htmlname</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.md$&#39;</span><span class="p">,</span> <span class="s1">&#39;.html&#39;</span><span class="p">,</span> <span class="n">mdfile</span><span class="p">)</span>
            <span class="n">convertHtml</span><span class="p">(</span><span class="n">mdfile</span><span class="p">,</span> <span class="n">htmlname</span><span class="p">,</span> <span class="n">style</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&#34;-----------------------------------&#34;</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&#34;</span><span class="si">%s</span><span class="s2"> を </span><span class="si">%s</span><span class="s2"> へ変換しました&#34;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mdfile</span><span class="p">,</span> <span class="n">htmlname</span><span class="p">))</span></code></pre></div>
<p>途中の<code>style.css</code>は任意のスタイルを記述したファイルを、pyファイルと同じフォルダに格納しておきます。</p>

<p>なお、style.cssの内容はとりあえず下記の内容を記述しています。用途に応じて、追記したり別のcssファイルに置き換えてもらえればいいかと思います。</p>
<div class="highlight"><pre class="chroma"><code class="language-css" data-lang="css"><span class="nt">body</span> <span class="p">{</span>

  <span class="k">font-family</span><span class="p">:</span> <span class="s2">&#34;Hiragino Kaku Gothic Pro&#34;</span><span class="p">,</span><span class="kc">sans-serif</span><span class="p">;</span>
  <span class="k">font-size</span><span class="p">:</span> <span class="mi">14</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">padding</span><span class="p">:</span> <span class="mi">0</span> <span class="mi">12</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">line-height</span><span class="p">:</span> <span class="mi">23</span><span class="kt">px</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">img</span> <span class="p">{</span>
  <span class="k">max-width</span><span class="p">:</span> <span class="mi">100</span><span class="kt">%</span><span class="p">;</span>
  <span class="k">max-height</span><span class="p">:</span> <span class="mi">100</span><span class="kt">%</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">hr</span> <span class="p">{</span>
  <span class="k">border</span><span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">height</span><span class="p">:</span> <span class="mi">2</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">border-bottom-width</span><span class="p">:</span> <span class="mi">2</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">border-bottom-style</span><span class="p">:</span> <span class="kc">dotted</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">h1</span> <span class="p">{</span>
  <span class="k">padding-bottom</span><span class="p">:</span> <span class="mf">0.4</span><span class="kt">em</span><span class="p">;</span>
  <span class="k">line-height</span><span class="p">:</span> <span class="mf">1.2</span><span class="p">;</span>
  <span class="k">border-bottom-width</span><span class="p">:</span> <span class="mi">1</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">border-bottom-style</span><span class="p">:</span> <span class="kc">solid</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">h1</span><span class="o">,</span> <span class="nt">h2</span><span class="o">,</span> <span class="nt">h3</span><span class="o">,</span> <span class="nt">h4</span><span class="o">,</span> <span class="nt">h5</span><span class="o">,</span> <span class="nt">h6</span> <span class="p">{</span>
  <span class="k">font-weight</span><span class="p">:</span> <span class="kc">normal</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>
<h2 id="参考文献">参考文献</h2>

<p><a href="https://python-markdown.github.io/">Python-Markdown</a></p>

<p><a href="http://oboe2uran.hatenablog.com/entry/2019/01/25/150934">Markdownファイルを Python で PDF にする</a></p>
]]></content>
		</item>
		
		<item>
			<title>VS CodeでMarkdownをPDFに自動で変換する</title>
			<link>https://idontwannawork.github.io/posts/convert-markdown-to-pdf-with-vscode/</link>
			<pubDate>Wed, 15 May 2019 13:44:12 +0900</pubDate>
			
			<guid>https://idontwannawork.github.io/posts/convert-markdown-to-pdf-with-vscode/</guid>
			<description>はじめに Markdownで記述したmdファイルは、エンジニア間ではそのまま利用することが多いように思います（GitHubなどにREADME.</description>
			<content type="html"><![CDATA[

<h2 id="はじめに">はじめに</h2>

<p>Markdownで記述したmdファイルは、エンジニア間ではそのまま利用することが多いように思います（GitHubなどにREADME.mdとしてアップするとか）。ところが、メールに添付したり印刷する等、外部へ持ち出す際はPDFに変換しておいた方がいろいろ安心。とくに「mdファイルって何？」みたいなお客さんにドキュメントを渡さないといけない場合とか・・・。</p>

<p>MarkdownをPDF化するのは、Pandocを利用する方法もあるのですが、ここではVisual Studio Code（以下、VS Code）の拡張機能である「<a href="https://marketplace.visualstudio.com/items?itemName=yzane.markdown-pdf">Markdown PDF</a>」を利用します。</p>

<h2 id="環境">環境</h2>

<ul>
<li>Windows 10</li>
<li>VS Code</li>
</ul>

<h2 id="インストール">インストール</h2>

<p>VS Codeにて、Ctrl＋Shift＋Xで拡張機能の検索窓に「Markdown PDF」と入力するか、上記のリンクをクリックします。検索結果から「Markdown PDF」を選択し、インストールします。Markdown PDFをインストールしてから、VS Codeで適当なMarkdownファイルを最初に開いた際、Chromiumのダウンロードが自動で始まります。ちなみに、なんでChromiumが必要かというと、Markdown PDFがPDF変換するのに利用しているから。</p>

<h2 id="使い方">使い方</h2>

<ol>
<li>PDF化したいMarkdownファイルを開く。</li>
<li>F1キーを押すか、Ctrl+Shift+Pキーを押しコマンドパレットを表示させる。</li>

<li><p>exportと入力すると下記のメニューが表示される。</p>

<ul>
<li>markdown-pdf: Export (settings.json)</li>
<li>markdown-pdf: Export (pdf)</li>
<li>markdown-pdf: Export (html)</li>
<li>markdown-pdf: Export (png)</li>
<li>markdown-pdf: Export (jpeg)</li>
<li>markdown-pdf: Export (all: pdf, html, png, jpeg)</li>
</ul>

<p>この中からExport (pdf)を選択する。</p></li>

<li><p>少し待つと、Markdownと同一のフォルダーにPDFが生成される。</p></li>
</ol>

<h2 id="自動化">自動化</h2>

<p>上記の使い方ではPDFへ変換するのに、毎回コマンドパレットを表示してコマンドを入力し、どのファイル形式でエクスポートするかを選択する必要があります。これを特定の変換先（今回はPDF）に限定して自動変換するよう設定します。</p>

<ol>
<li><p>「ファイル」メニュー＞「基本設定」＞「設定」を選択するか、<code>Ctrl＋,</code>で直接画面を開く。</p></li>

<li><p>setting.jsonファイルを開いて下記のように設定する。</p>

<pre><code>&quot;markdown-pdf.convertOnSave&quot;: true,
&quot;markdown-pdf.type&quot;: [
    &quot;pdf&quot;
],
</code></pre></li>

<li><p>設定内容を書き込んだらVS Codeを1度再起動する。</p></li>
</ol>

<p>これで、Markdownファイルを編集し保存したタイミングで自動的にPDFへ変換するようになります。</p>

<h2 id="注意">注意</h2>

<p>この拡張機能は変換したファイルの出力先を変更できないので、必ずMarkdownファイルが格納されているフォルダーと同じ場所に出力されます。また、出力先ファイル名も指定できないので、同一名のファイルが既存である場合は自動的に上書きします。</p>
]]></content>
		</item>
		
		<item>
			<title>イテレータを複数回ループしたい</title>
			<link>https://idontwannawork.github.io/posts/iterator-will-return-blank-with-loop-twice/</link>
			<pubDate>Wed, 15 May 2019 11:57:24 +0900</pubDate>
			
			<guid>https://idontwannawork.github.io/posts/iterator-will-return-blank-with-loop-twice/</guid>
			<description>なんのこっちゃ？ 実行しようとしていたのはこんなコードでした。 &amp;gt;&amp;gt;&amp;gt; import re &amp;gt;&amp;gt;&amp;gt; s = &amp;quot;hogefugapiyofoobarbaz1234567890abc987efg654hij321&amp;quot; &amp;gt;&amp;gt;&amp;gt; iter = re.finditer(&amp;quot;b..&amp;quot;, s) ← finditer()は結果をイテレータで返す &amp;gt;&amp;gt;&amp;gt; for i in iter:</description>
			<content type="html"><![CDATA[

<h2 id="なんのこっちゃ">なんのこっちゃ？</h2>

<p>実行しようとしていたのはこんなコードでした。</p>

<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; s = &quot;hogefugapiyofoobarbaz1234567890abc987efg654hij321&quot;
&gt;&gt;&gt; iter = re.finditer(&quot;b..&quot;, s)    ← finditer()は結果をイテレータで返す
&gt;&gt;&gt; for i in iter:
...     print(i.start())
...
15
18
32
&gt;&gt;&gt; for i in iter:
...     print(i.start())
...
&gt;&gt;&gt;    ← 同じループを実行しても最初のループと異なり結果が返ってこない
</code></pre>

<p>このように、同一のイテレータに対しループ処理を複数回行うと、2回目以降のループは結果が空になってしまいます。</p>

<p>ちなみにジェネレータでも上記のような複数回のループ処理を行おうとすると、<a href="https://qiita.com/tomotaka_ito/items/15b5999c76001dbc9a58">2回目以降のループで結果が空になる</a>らしいですが、ジェネレータについては別途まとめて記事にしようと思います（まだ勉強中）。</p>

<h2 id="なんでこーなるの">なんでこーなるの？</h2>

<p><a href="https://docs.python.org/ja/3/glossary.html#term-iterator">イテレータ</a>が持つ要素を取得したい場合、__next__() メソッド（または組み込み関数の<code>next()</code>）を繰り返し呼び出すと、イテレータ中の要素を1つずつ返します。このメソッドは集合から1つずつ要素を<strong>取り出して</strong>います。取り出しているので、すべて取り出し終わったら元の集合には要素が存在しません。よって2回目以降のループは空っぽになります（要素がない場合は、StopIteration例外を返す）。</p>

<p>※「取り出す」という表現が正確かどうかはちょっと自信がありません。メソッドや関数の「next」という名前の通り「次の要素へ」という挙動と、同じ要素を複数回取得できないことから「取り出す」という表現を使っています。</p>

<p>なお、直接関係はありませんが、<a href="https://docs.python.org/ja/3/library/functions.html#map"><code>map()</code></a>や<a href="https://docs.python.org/ja/3/library/functions.html#filter"><code>filter()</code></a>はイテレータを返す（Python3での話）ので、返されたオブジェクトについて<code>list()</code>などを複数回実行すると、上記のように<a href="https://stackoverflow.com/questions/19759247/listing-a-filter-object-twice-will-return-a-blank-list">2回目以降は空っぽになってしまう</a>ようです。</p>

<pre><code>&gt;&gt;&gt; list = [1, 2, 3]
&gt;&gt;&gt; f = filter(None, list)
&gt;&gt;&gt; list(list)
[1, 2, 3]
&gt;&gt;&gt; list(list)
[1, 2, 3] ← リストlistに複数回listしても結果が返ってくる
&gt;&gt;&gt; list(f)
[1, 2, 3]
&gt;&gt;&gt; list(f)
[] ← イテレータに複数回listすると2回目以降ブランクになる
&gt;&gt;&gt;
</code></pre>

<h2 id="そもそもイテレータって">そもそもイテレータって？</h2>

<p><a href="https://docs.python.org/ja/3/glossary.html#term-iterator">iterator</a>とはオブジェクトの一種で、データの走査方法について表現するものです。なんのこっちゃ、という感じですが「要素を1つずつ繰り返し取得できる構造を持っていて（<code>iterable</code>）、実際に順次取得ができる」オブジェクトっていう感じかと。</p>

<pre><code>&gt;&gt;&gt; list = [1, 2, 3]
&gt;&gt;&gt; i = iter(list)
&gt;&gt;&gt; type(list)
&lt;class 'list'&gt;
&gt;&gt;&gt; type(i)
&lt;class 'list_iterator'&gt;
&gt;&gt;&gt; print(next(i))
1
&gt;&gt;&gt; print(next(i))
2
&gt;&gt;&gt; print(next(i))
3
&gt;&gt;&gt; print(next(i))
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
StopIteration ← 「これ以上next()で取り出せる要素ねぇよ！」と言っている
&gt;&gt;&gt;
</code></pre>

<p>これと似たオブジェクトに<a href="https://docs.python.org/ja/3/glossary.html#term-iterable">itetable</a>（反復可能オブジェクト）があります。こちらはデータの構造そのものについて表現しており、<code>iterator</code>とは別物です。たとえばリストやタプル、辞書などは<code>iterable</code>で、オブジェクトに対しアクセスすることで、要素を1つずつ取得することができる<strong>構造</strong>のことを指しています。つまり、先述の<code>iterator</code>は<code>iterable</code>に含まれるわけです。</p>

<p>ちなみに「iterable」の英単語本来の意味は<a href="https://ejje.weblio.jp/content/iterable">「繰り返し可能な」という形容詞</a>。</p>

<h2 id="どうすれば回避できる">どうすれば回避できる？</h2>

<h3 id="変数に格納する">変数に格納する</h3>

<p>再利用したいなら、単純に変数へ格納しちゃえという方法。</p>

<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; s = &quot;hogefugapiyofoobarbaz1234567890abc987efg654hij321&quot;
&gt;&gt;&gt; iter = re.finditer(&quot;b..&quot;, s)
&gt;&gt;&gt; type(iter)
&lt;class 'callable_iterator'&gt;
&gt;&gt;&gt; lists = list(iter)
&gt;&gt;&gt; type(lists)
&lt;class 'list'&gt;
&gt;&gt;&gt; for i in lists:
...     print(i)
...
&lt;_sre.SRE_Match object; span=(15, 18), match='bar'&gt;
&lt;_sre.SRE_Match object; span=(18, 21), match='baz'&gt;
&lt;_sre.SRE_Match object; span=(32, 35), match='bc9'&gt;
&gt;&gt;&gt; for i in lists:
...     print(i.start())
...
15
18
32
&gt;&gt;&gt; for i in lists:
...     print(i.start())
...
15
18
32    ← 複数回ループしても結果が返ってきている
&gt;&gt;&gt;
</code></pre>

<p><code>filter()</code>などのイテレータを返すものも同様。</p>

<pre><code>&gt;&gt;&gt; list = [1, 2, 3]
&gt;&gt;&gt; f = filter(None, list)
&gt;&gt;&gt; type(f)
&lt;class 'filter'&gt;
&gt;&gt;&gt; listed = list(f)
&gt;&gt;&gt; type(listed)
&lt;class 'list'&gt;
&gt;&gt;&gt; list(listed)
[1, 2, 3]
&gt;&gt;&gt; list(listed)
[1, 2, 3]
&gt;&gt;&gt; list(f)
[]
&gt;&gt;&gt;
</code></pre>

<h3 id="リストでループする">リストでループする</h3>

<p>今回の場合で言うと<code>finditer()</code>ではなく<code>findall()</code>を用いて、イテレータでなくリストでループするようにします。</p>

<pre><code>&gt;&gt;&gt; list = re.findall(&quot;b..&quot;, s)
&gt;&gt;&gt; for item in list:
...     print(item)
...
bar
baz
bc9
&gt;&gt;&gt; for item in list:
...     print(item)
...
bar
baz
bc9
</code></pre>

<p><code>findall()</code>はリストを返すメソッド。リスト<code>list</code>に対しては、ループ処理を何回行っても同様な結果が出力されます。これなら上記のような問題は発生しませんが、このあたりは要求される機能と相談する必要があると思います。</p>

<h3 id="itertoolsを用いる">itertoolsを用いる</h3>

<p>再利用する回数が事前に分かっているなら<code>itertools.tee()</code>を利用する方法もあります。</p>

<pre><code>&gt;&gt;&gt; import itertools
&gt;&gt;&gt; list = [1, 2, 3]
&gt;&gt;&gt; i = iter(list)
&gt;&gt;&gt; i1, i2, i3 = itertools.tee(i, 3) ← 3回再利用する必要があると仮定
&gt;&gt;&gt; for n in i1:
...     print(n)
...
1
2
3
&gt;&gt;&gt; for n in i1:
...     print(n)
...
&gt;&gt;&gt; for n in i2:
...     print(n)
...
1
2
3
&gt;&gt;&gt; for n in i2:
...     print(n)
...
&gt;&gt;&gt; for n in i3:
...     print(n)
...
1
2
3
&gt;&gt;&gt; for n in i3:
...     print(n)
...
&gt;&gt;&gt;
</code></pre>

<p>ただ、個人的にはこの方法を利用するようなシチュエーションがあまり思い浮かばない・・・。</p>

<h2 id="おわりに">おわりに</h2>

<p>「ん？何で同じ条件なのにループすると空っぽになるんじゃ？」と素朴に思ったのが始まりなのですが、調べてみると案外深い仕様になっていて勉強になりました（小並感）。</p>

<p>ちなみに、複数回ループしようとしてた理由は、原因を調べているうちに忘れました（鳥頭）。</p>
]]></content>
		</item>
		
		<item>
			<title>Vue.jsでデータの内容を開発ツールを使わないで確認する</title>
			<link>https://idontwannawork.github.io/posts/show-data-without-tools/</link>
			<pubDate>Sun, 05 May 2019 17:38:31 +0900</pubDate>
			
			<guid>https://idontwannawork.github.io/posts/show-data-without-tools/</guid>
			<description>小ネタです Vue.jsは、ブラウザの開発ツールやVue.js用の拡張機能を利用しなくても、HTMLファイルにとあるタグを記述することで、デー</description>
			<content type="html"><![CDATA[

<h2 id="小ネタです">小ネタです</h2>

<p>Vue.jsは、ブラウザの開発ツールやVue.js用の拡張機能を利用しなくても、HTMLファイルに<strong>とあるタグ</strong>を記述することで、データの内容をJSON形式で確認できます。</p>

<h3 id="記述方法">記述方法</h3>

<p>HTMLファイル内に「<code>{{ $data }}</code>」を任意の場所に記述します。</p>

<pre><code>&lt;html&gt;
    &lt;head&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;app&quot;&gt;
        &lt;p&gt;{{ message.v }}&lt;/p&gt;
        &lt;p&gt;{{ message.v.length }}&lt;/p&gt;
        &lt;p&gt;{{ l[2] }}&lt;/p&gt;
        &lt;p&gt;{{ l[n] }}&lt;/p&gt;
        &lt;pre&gt;{{ $data }}&lt;/pre&gt;
        &lt;/div&gt;
        &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.13/dist/vue.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>仮にJavaScript側が下記の内容だった場合、</p>

<pre><code>var app = new Vue({
    el: '#app',
    data: {
        message: {
        v: 'Hello Vue World!'
        },
        l: ['hoge', 'ふが', 'ぴyo'],
        n: 1
    }
})
</code></pre>

<p>表示内容は下記の通り。</p>

<p><img src="2019-05-05-17-48-12.png" alt="" /></p>

<p>CodePenでやってみました。</p>

<p><p class="codepen" data-height="265" data-theme-id="0" data-default-tab="html,result" data-user="idontwannawork" data-slug-hash="yrmOOJ" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="vuejs_type">
  <span>See the Pen <a href="https://codepen.io/idontwannawork/pen/yrmOOJ/">
  vuejs_type</a> by idontwannawork (<a href="https://codepen.io/idontwannawork">@idontwannawork</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script></p>

<p>あんまり複雑なデータを出力すると、かえって見にくくなってしまうと思われますが、ちょっとした確認には十分に利用できるかな。</p>
]]></content>
		</item>
		
		<item>
			<title>Pythonのopen関数はencoding引数を指定しよう</title>
			<link>https://idontwannawork.github.io/posts/encode-error-with-open-function/</link>
			<pubDate>Thu, 25 Apr 2019 10:57:12 +0900</pubDate>
			
			<guid>https://idontwannawork.github.io/posts/encode-error-with-open-function/</guid>
			<description>結論 WindowsでPythonのopen関数を使うなら、encoding引数を指定しよう（血涙 何があったのさ WindowsにてPython</description>
			<content type="html"><![CDATA[

<h2 id="結論">結論</h2>

<p>WindowsでPythonのopen関数を使うなら、<strong>encoding引数を指定しよう</strong>（血涙</p>

<h2 id="何があったのさ">何があったのさ</h2>

<p>WindowsにてPythonを用いて、テキストファイルの書き出しと読み込みをしようとしたんです。</p>

<p>そうしたら憎きアイツが出てきたわけです。</p>

<p><img src="2019-04-25-13-12-56.png" alt="pic" /></p>

<p>出たよ、<code>UnicodeDecodeError</code>・・・。</p>

<h2 id="環境">環境</h2>

<ul>
<li>Windows 10</li>
<li>Python 3.6</li>
<li>Visual Studio Code</li>
</ul>

<h2 id="コード">コード</h2>

<pre><code>s = '\x85'
print(s)

with open('C:/app/hoge.txt', mode='w', encoding='utf-8') as f:
    f.write(s)

with open('C:/app/hoge.txt', mode='r') as g:
    print(g.read())        # UnicodeDecodeError`でエラー
</code></pre>

<blockquote>
<p>※問題の部分だけ抜粋しています。本来のソースは入力の文字列がもっとごちゃごちゃしてました。</p>
</blockquote>

<h2 id="原因">原因</h2>

<p>つまるところ、読み込み時の<code>open</code>で引数の<code>encoding</code>を指定していなかったからでした_:(´ཀ`」∠):_</p>

<p>書き出しの際には下記のように<code>encoding</code>を指定していました。</p>

<pre><code>with open('C:/app/hoge.json', mode='w', encoding='utf-8') as f:
</code></pre>

<p>ただ、書き出したファイルを読み込む際に、<code>encoding</code>の指定を失念していました。</p>

<pre><code>with open('C:/app/hoge.json', mode='r') as g:
</code></pre>

<p><code>encoding</code>の指定がない場合については、<a href="https://docs.python.org/ja/3/library/functions.html#open">オフィシャル</a>だと下記のように説明されています。</p>

<blockquote>
<p>encoding が指定されていない場合に使われるエンコーディングはプラットフォームに依存します</p>
</blockquote>

<p>Windowsだと利用されるエンコーディングはCP932です。Pythonから入出力する際、CP932に変換できない文字が存在したため、「変換できないよ！」とエラーになったわけです。</p>

<h2 id="ちなみに">ちなみに</h2>

<p>Python内部では文字列型は<a href="https://docs.python.org/ja/3/library/stdtypes.html#text-sequence-type-str">Unicodeで保持</a>されています。そして、入出力の際はPythonがシステムのエンコーディングに<strong>自動で変換</strong>してくれます。この場合、もともとUTF-8で保持されていたものをCP932に変換します。</p>

<p>この変換をユーザーが意識する必要はありません。逆に言えば、知らない間に<strong>勝手に</strong>変換されます。そして、この自動変換の際に何かしらの「変換できない文字」があるとエラーになる、というわけです。</p>

<h2 id="解消方法">解消方法</h2>

<p>エラーを解消するには、書き出し時と同様に読み込み時にも<code>encoding</code>を指定する必要があります。</p>

<pre><code>with open('C:/app/hoge.json', mode='r', encoding=&quot;utf-8) as f:
    j = json.load(g)
</code></pre>

<p>ちなみに、書き出しの際に<code>encoding</code>を指定しなかった場合も、読み込みと同様にエラーになります。当然っちゃ当然ですね。</p>

<p><img src="2019-04-25-13-13-57.png" alt="pic" /></p>

<p>とりあえず今回は、両方に<code>encoding</code>を指定する方法を取りました。</p>

<h2 id="おわりに">おわりに</h2>

<p><code>encoding</code>を指定のは、手癖にしておくべきだと思いました（小並感</p>

<h2 id="参考文献">参考文献</h2>

<ul>
<li><a href="https://docs.python.org/ja/3.7/index.html">Pythonドキュメント</a></li>
<li><a href="https://qiita.com/butada/items/33db39ced989c2ebf644">(Windows) Python3でのUnicodeEncodeErrorの原因と回避方法</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>json.dumpsでの文字化けを解消する</title>
			<link>https://idontwannawork.github.io/posts/garbled-text-with-json-dumps/</link>
			<pubDate>Wed, 24 Apr 2019 10:38:54 +0900</pubDate>
			
			<guid>https://idontwannawork.github.io/posts/garbled-text-with-json-dumps/</guid>
			<description>概要 Pythonでjson.dumps()した際に、日本語が文字化けするのを防ぐメモ。 環境 Windows 10 Python 3.6 実際のコード &amp;gt;&amp;gt;&amp;gt; import json &amp;gt;&amp;gt;&amp;gt; dic = {&amp;quot;hoge&amp;quot;:&amp;quot;foo&amp;quot;, &amp;quot;fuga&amp;quot;:&amp;quot;bar&amp;quot;, &amp;quot;piyo&amp;quot;:&amp;quot;baz&amp;quot;} &amp;gt;&amp;gt;&amp;gt; json.dumps(dic) &#39;{&amp;quot;hoge&amp;quot;: &amp;quot;foo&amp;quot;, &amp;quot;fuga&amp;quot;: &amp;quot;bar&amp;quot;,</description>
			<content type="html"><![CDATA[

<h2 id="概要">概要</h2>

<p>Pythonで<code>json.dumps()</code>した際に、日本語が文字化けするのを防ぐメモ。</p>

<h2 id="環境">環境</h2>

<ul>
<li>Windows 10</li>
<li>Python 3.6</li>
</ul>

<h2 id="実際のコード">実際のコード</h2>

<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; dic = {&quot;hoge&quot;:&quot;foo&quot;, &quot;fuga&quot;:&quot;bar&quot;, &quot;piyo&quot;:&quot;baz&quot;}
&gt;&gt;&gt; json.dumps(dic)
'{&quot;hoge&quot;: &quot;foo&quot;, &quot;fuga&quot;: &quot;bar&quot;, &quot;piyo&quot;: &quot;baz&quot;}'
&gt;&gt;&gt; dicj = {&quot;日本語&quot;:&quot;項目名&quot;, &quot;にほんご&quot;:&quot;こうもくめい&quot;}
&gt;&gt;&gt; json.dumps(dicj)
'{&quot;\\u65e5\\u672c\\u8a9e&quot;: &quot;\\u9805\\u76ee\\u540d&quot;, &quot;\\u306b\\u307b\\u3093\\u3054&quot;: &quot;\\u3053\\u3046\\u3082\\u304f\\u3081\\u3044&quot;}'
</code></pre>

<p>こんな感じで、単純に<code>json.dumps()</code>すると文字化けしてしまいます。この場合、<code>ensure_ascii</code>オプションで<code>False</code>を指定します。</p>

<pre><code>&gt;&gt;&gt; json.dumps(dicj, ensure_ascii=False)
'{&quot;日本語&quot;: &quot;項目名&quot;, &quot;にほんご&quot;: &quot;こうもくめい&quot;}'
</code></pre>

<p>すると、上記のように文字化けが解消されました。</p>
]]></content>
		</item>
		
		<item>
			<title>Windowsでドット付ファイルを作成する</title>
			<link>https://idontwannawork.github.io/posts/make-file-with-dot-on-windows/</link>
			<pubDate>Mon, 22 Apr 2019 13:06:22 +0900</pubDate>
			
			<guid>https://idontwannawork.github.io/posts/make-file-with-dot-on-windows/</guid>
			<description>結論 ファイル名の冒頭および語尾の両方にドットを付与！ 小ネタです .gitignoreとか.bashrcのように、何かの設定ファイルは冒頭に「.</description>
			<content type="html"><![CDATA[

<h2 id="結論">結論</h2>

<p>ファイル名の冒頭および語尾の両方にドットを付与！</p>

<h2 id="小ネタです">小ネタです</h2>

<p><code>.gitignore</code>とか<code>.bashrc</code>のように、何かの設定ファイルは冒頭に「.（ドット）」が付いて拡張子なしであるような名前だったりします。</p>

<p>ところが、Windowsのexplorer上でドット付のファイルを作成しようとしたらエラーになりました。</p>

<p>たとえば<code>.hoge</code>という名前のファイルを作成しようとします。</p>

<p><img src="2019-04-22-13-09-06.png" alt="alt text" /></p>

<p>こんな名前のファイルを作成しようとすると・・・</p>

<p><img src="2019-04-22-13-09-27.png" alt="alt text" /></p>

<p>エラー！</p>

<h2 id="対策">対策</h2>

<p>そういう場合は、下記のようにファイル名の冒頭および語尾の両方にドットを付与してやるとファイルを作成できます。</p>

<pre><code>.hoge.
</code></pre>

<p><img src="2019-04-22-13-10-14.png" alt="alt text" /></p>

<p>すると・・・</p>

<p><img src="2019-04-22-13-10-28.png" alt="alt text" /></p>

<p>「はい」を押せばドット付ファイルのできあがりです。</p>

<p><img src="2019-04-22-13-11-07.png" alt="alt text" /></p>
]]></content>
		</item>
		
	</channel>
</rss>
